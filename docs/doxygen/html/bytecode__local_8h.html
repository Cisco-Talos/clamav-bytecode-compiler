<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>bytecode_local.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('bytecode__local_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bytecode_local.h File Reference</div>  </div>
</div>
<div class="contents">

<p><a href="bytecode__local_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_i_s__mem__arg.html">DIS_mem_arg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_i_s__arg.html">DIS_arg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_i_s__fixed.html">DIS_fixed</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#af46256c8838bde91b834ae7323f325c9">VIRUSNAME_PREFIX</a>(name)&#160;&#160;&#160;const char __clambc_virusname_prefix[] = name;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a07e03751d8c0faf422b28d7138f69a57">VIRUSNAMES</a>(...)&#160;&#160;&#160;const char *const __clambc_virusnames[] = {__VA_ARGS__};</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#adab197e0485a688211ac7f6add222691">PE_UNPACKER_DECLARE</a>&#160;&#160;&#160;const uint16_t <a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a> = BC_PE_UNPACKER;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a96c0aeeec87fbf8c08a2dd17c86f4cb0">PDF_HOOK_DECLARE</a>&#160;&#160;&#160;const uint16_t <a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a> = BC_PDF;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a6b52cfd01216f68d830d874feb25e07c">BYTECODE_ABORT_HOOK</a>&#160;&#160;&#160;0xcea5e</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#aab7294d18a5e7d7c16234c4afe573d44">PE_HOOK_DECLARE</a>&#160;&#160;&#160;const uint16_t <a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a> = BC_PE_ALL;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a9d8dab26434a3a759f8934956f87c822">SIGNATURES_DECL_BEGIN</a>&#160;&#160;&#160;struct __Signatures {</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a9cc5358469543c230937ff04cb545a72">DECLARE_SIGNATURE</a>(name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a75c0ab3e5d9f66a1e134c823200d295d">SIGNATURES_DECL_END</a>&#160;&#160;&#160;};</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a8f4214a187b6ecb97ad7eef2317ebd3f">TARGET</a>(tgt)&#160;&#160;&#160;const unsigned short __Target = (tgt);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a07318d0dd98e1eea463bb91dcbca277c">COPYRIGHT</a>(c)&#160;&#160;&#160;const char *const __Copyright = (c);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a543de9b69d68ba528f60634777f72a5d">ICONGROUP1</a>(group)&#160;&#160;&#160;const char *const __IconGroup1 = (group);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a655d7e9c6fcfec9b860d0acc56066326">ICONGROUP2</a>(group)&#160;&#160;&#160;const char *const __IconGroup2 = (group);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a550536f35a9af1cf46db818baffe7912">FUNCTIONALITY_LEVEL_MIN</a>(m)&#160;&#160;&#160;const unsigned short __FuncMin = (m);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#afc471efa427277a2b96a2a06ba647aa9">FUNCTIONALITY_LEVEL_MAX</a>(m)&#160;&#160;&#160;const unsigned short __FuncMax = (m);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#af75911dca13ab8a873fe2bafd57a705a">SIGNATURES_DEF_BEGIN</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#af17ef9c55c87be7943edda3732ed34b4">DEFINE_SIGNATURE</a>(name, hex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ac9b976f78a0dac8a6996cbb31571044f">SIGNATURES_END</a>&#160;&#160;&#160;};\</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline void <br class="typebreak"/>
overloadable_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#aa6f11e14ec5677b64c7f623a08a81ceb">debug</a> (const char *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline void <br class="typebreak"/>
overloadable_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a7393b44e1359ec29419ccee63a730716">debug</a> (const uint8_t *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline void <br class="typebreak"/>
overloadable_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a86350ab4540ed8cc1607409355a1b04c">debug</a> (uint32_t a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a37106786ad5566aa9fd1c8c1a0293029">debug</a> (...) __attribute__((overloadable</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a3bee86d89c2e0d16b706f62ec0c2d716">count_match</a> (__Signature sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#afb7a07b6a6a5826f43f624fa1af2a8c6">matches</a> (__Signature sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a0731ae7f531521a4c8609d75a21d3edd">match_location</a> (__Signature sig, uint32_t goback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ae815c917305f5ce574b0e759f605819b">match_location_check</a> (__Signature sig, uint32_t goback, const char *static_start, uint32_t static_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline <br class="typebreak"/>
overloadable_func void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a95f6c4104903cf54fead01646fd7f9d2">foundVirus</a> (const char *virusname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline void <br class="typebreak"/>
overloadable_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ad81d7009247e53d5074a464b3a59454c">foundVirus</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a4dfb3482a7f04ae1e51942755253d720">getFilesize</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#af3a7e5cbd0c798faf98a03ee7c72e661">__is_bigendian</a> (void) __attribute__((const )) __attribute__((nothrow))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t force_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a9d6c63ead621ba606fe4d01b4558a9dc">le32_to_host</a> (uint32_t v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t force_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a574fdd0c27b3c4d8289f346edb2ffc2e">le64_to_host</a> (uint64_t v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint16_t force_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a9e0a2862823999029c872ee352df036d">le16_to_host</a> (uint16_t v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t force_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a3d6a38ce39dd509a2526a67f8f00f845">cli_readint32</a> (const void *buff)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint16_t force_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a50ecabc9fb33d2194b257d68fc136eed">cli_readint16</a> (const void *buff)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void force_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ae275f25ed41739954c981ed4717ebd22">cli_writeint32</a> (void *offset, uint32_t v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a6241ff42b1300527c64034931f027738">hasExeInfo</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#abfb2cd189ec07a4e521a906581e421e6">hasPEInfo</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a7480d681206faafd4c0f1923938dd5fe">isPE64</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static static force_inline <br class="typebreak"/>
force_inline uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a0563ea1400d07e675a20ab0dcfd905eb">getPEMajorLinkerVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ac77d151a09c2de3b1d803567d24892b3">getPEMinorLinkerVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ad9f53af41bcca14d46ce507e2e6ab16c">getPESizeOfCode</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a50cf975bcf2f8fff010b8a8a26bb8ada">getPESizeOfInitializedData</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a8bcd1876daa53ee94772ada292b039d8">getPESizeOfUninitializedData</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a4856f8c8b2250e9ff7a15bfc651e9dc5">getPEBaseOfCode</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a906067648342e627e35608446ae28faf">getPEBaseOfData</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a5be87a6ddd3f434c8755a54b441da600">getPEImageBase</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a564b495dcdeaccf29a0ad97046be73c1">getPESectionAlignment</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a3d3676596ffad052f01ed7355062921c">getPEFileAlignment</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a220d77f9285699cf6bfda4b629193aea">getPEMajorOperatingSystemVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a5b621a2c5114f83e6e1b2a2648b17909">getPEMinorOperatingSystemVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#aea163191c14a5af87883231d7358070f">getPEMajorImageVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a3c2af71ce767165317d0da8f8a23dc24">getPEMinorImageVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a9c6364f035901ed9983edc13a709f8f4">getPEMajorSubsystemVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ab8516cf0fd00093557a6b84e766f21cf">getPEMinorSubsystemVersion</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a20c5188f3da8c956592847265abc287b">getPEWin32VersionValue</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a2a8e7a0acac5e007bfb4e28d57f3170f">getPESizeOfImage</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a80cc732b7672ea102d4704946c6eb2aa">getPESizeOfHeaders</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a07f9eaa84e03e09a833facf15d170bff">getPECheckSum</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a4027528d4bc10b3b736bf733db903dd1">getPESubsystem</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a307bc20f197de9d15bb6e08e9d8f3785">getPEDllCharacteristics</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the PE DllCharacteristics.  <a href="#a307bc20f197de9d15bb6e08e9d8f3785"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a61370982c310e3aeed974dd0abe02284">getPESizeOfStackReserve</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ae99c81416872de61956e064fc1e32550">getPESizeOfStackCommit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#aea6b290ae054a0b872887071b4b0f9f2">getPESizeOfHeapReserve</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ae9c031fc42de436f574943f089c508c5">getPESizeOfHeapCommit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#adae84c4057d5721d9606218d3eed5e34">getPELoaderFlags</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a01fe1e273462c9386b45f7661d15b55a">getPEMachine</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a28e4809837328528a644c53d8a864fc6">getPETimeDateStamp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a3edd1734cfe7362eb26f6d6630fefb00">getPEPointerToSymbolTable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a49632081cf680004297e0b2ce99c6cb8">getPENumberOfSymbols</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a22825914a55dbe5d5548a5e07bb0b24d">getPESizeOfOptionalHeader</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ab93887618aa8cebb250f28574634093a">getPECharacteristics</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a027ee938f8372e45d6fe6197d10ecc96">getPEisDLL</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ab9e2deafba57fe896c13e38e5d45be9e">getPEDataDirRVA</a> (unsigned n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a19dd537d51a4bfe23f58a92b2332ed02">getPEDataDirSize</a> (unsigned n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#acc59dfc3eb084259883225674083e553">getNumberOfSections</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a0ed633b358ee0280504b9e2b55492a8d">getPELFANew</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a783b0c34b69dfcdcc3c00e0172e53938">readPESectionName</a> (unsigned char name[8], unsigned n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ad26217bb0fe3c43d933bf48b9957bc53">getEntryPoint</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ae06107422b3a2bd8a9a07fb344e8a8da">getExeOffset</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a20fbd92de54ff30ade353ca8381ec766">getImageBase</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a488ebd9cda9e8ba46ba5daae94ddb453">getVirtualEntryPoint</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#aedc2fa35d4664099b528c68653f593f2">getSectionRVA</a> (unsigned i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ad81443723d60b2eaf56aa13718a0bf47">getSectionVirtualSize</a> (unsigned i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a59c863dbbe659efa59f38a45dfc0094c">readRVA</a> (uint32_t rva, void *buf, size_t bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a2a215ee7d930373a5df739a91ffdc10f">memchr</a> (const void *s, int c, size_t n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a9877bb88a253a26e4dbbeeff654475a7">memset</a> (void *src, int c, uintptr_t n) __attribute__((nothrow)) __attribute__((__nonnull__((1))))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a39f394f696d30ad1fe11cf7855d33427">memmove</a> (void *dst, const void *src, uintptr_t n) __attribute__((__nothrow__)) __attribute__((__nonnull__(1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#ac230c6c8d1f7ec41aed26b482001523c">memcpy</a> (void *restrict dst, const void *restrict src, uintptr_t n) __attribute__((__nothrow__)) __attribute__((__nonnull__(1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *void int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a275fa6d98ae5fb2c574d7b4cfdf0ec6c">memcmp</a> (const void *s1, const void *s2, uint32_t n) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__(1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static force_inline uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a1a801c0806f1cb7ed433f139e5769f99">DisassembleAt</a> (struct <a class="el" href="struct_d_i_s__fixed.html">DIS_fixed</a> *result, uint32_t offset, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__local_8h.html#a3c9b722b5ff4d35cfcd8de8a5c48a0ed">ilog2_compat</a> (uint32_t a, uint32_t b)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a6b52cfd01216f68d830d874feb25e07c"></a><!-- doxytag: member="bytecode_local.h::BYTECODE_ABORT_HOOK" ref="a6b52cfd01216f68d830d874feb25e07c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTECODE_ABORT_HOOK&#160;&#160;&#160;0xcea5e</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>entrypoint() return code that tells hook invoker that it should skip executing, probably because it'd trigger a bug in it </p>

</div>
</div>
<a class="anchor" id="a07318d0dd98e1eea463bb91dcbca277c"></a><!-- doxytag: member="bytecode_local.h::COPYRIGHT" ref="a07318d0dd98e1eea463bb91dcbca277c" args="(c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COPYRIGHT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;const char *const __Copyright = (c);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines an alternative copyright for this bytecode. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000010">config:</a></b></dt><dd>This will also prevent the sourcecode from being embedded into the bytecode </dd></dl>

</div>
</div>
<a class="anchor" id="a9cc5358469543c230937ff04cb545a72"></a><!-- doxytag: member="bytecode_local.h::DECLARE_SIGNATURE" ref="a9cc5358469543c230937ff04cb545a72" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_SIGNATURE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span> *name##_sig;\
    __Signature name;
</pre></div><p>Declares a name for a subsignature. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000007">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af17ef9c55c87be7943edda3732ed34b4"></a><!-- doxytag: member="bytecode_local.h::DEFINE_SIGNATURE" ref="af17ef9c55c87be7943edda3732ed34b4" args="(name, hex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_SIGNATURE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hex&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">.name##_sig = (hex),\
    .name = {__COUNTER__ - __signature_bias},
</pre></div><p>Defines the pattern for a previously declared subsignature. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bytecode__local_8h.html#a9cc5358469543c230937ff04cb545a72">DECLARE_SIGNATURE</a> </dd></dl>
<dl class="config"><dt><b><a class="el" href="config.html#_config000016">config:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of a previously declared subsignature </td></tr>
    <tr><td class="paramname">hex</td><td>the pattern for this subsignature </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc471efa427277a2b96a2a06ba647aa9"></a><!-- doxytag: member="bytecode_local.h::FUNCTIONALITY_LEVEL_MAX" ref="afc471efa427277a2b96a2a06ba647aa9" args="(m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNCTIONALITY_LEVEL_MAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;const unsigned short __FuncMax = (m);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define the maximum engine functionality level required for this bytecode/logical signature. Engines newer than this will skip loading the bytecode. You can use the 'enum FunctionalityLevels' constants here. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000014">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a550536f35a9af1cf46db818baffe7912"></a><!-- doxytag: member="bytecode_local.h::FUNCTIONALITY_LEVEL_MIN" ref="a550536f35a9af1cf46db818baffe7912" args="(m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNCTIONALITY_LEVEL_MIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;const unsigned short __FuncMin = (m);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define the minimum engine functionality level required for this bytecode/logical signature. Engines older than this will skip loading the bytecode. You can use the 'enum FunctionalityLevels' constants here. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000013">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a543de9b69d68ba528f60634777f72a5d"></a><!-- doxytag: member="bytecode_local.h::ICONGROUP1" ref="a543de9b69d68ba528f60634777f72a5d" args="(group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ICONGROUP1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">group</td><td>)</td>
          <td>&#160;&#160;&#160;const char *const __IconGroup1 = (group);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define IconGroup1 for logical signature.</p>
<p>See logical signature documentation for what it is </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000011">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a655d7e9c6fcfec9b860d0acc56066326"></a><!-- doxytag: member="bytecode_local.h::ICONGROUP2" ref="a655d7e9c6fcfec9b860d0acc56066326" args="(group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ICONGROUP2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">group</td><td>)</td>
          <td>&#160;&#160;&#160;const char *const __IconGroup2 = (group);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define IconGroup2 for logical signature. See logical signature documentation for what it is. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000012">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a96c0aeeec87fbf8c08a2dd17c86f4cb0"></a><!-- doxytag: member="bytecode_local.h::PDF_HOOK_DECLARE" ref="a96c0aeeec87fbf8c08a2dd17c86f4cb0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PDF_HOOK_DECLARE&#160;&#160;&#160;const uint16_t <a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a> = BC_PDF;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make the current bytecode a PDF hook. Having a logical signature doesn't make sense here, since logical signature is evaluated AFTER these hooks run. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000004">config:</a></b></dt><dd>This hook is called several times, use <a class="el" href="bytecode__api_8h.html#af7eb372ae4bc42a552e543ea2a306f5e">pdf_get_phase()</a> to find out in which phase you got called. </dd></dl>

</div>
</div>
<a class="anchor" id="aab7294d18a5e7d7c16234c4afe573d44"></a><!-- doxytag: member="bytecode_local.h::PE_HOOK_DECLARE" ref="aab7294d18a5e7d7c16234c4afe573d44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PE_HOOK_DECLARE&#160;&#160;&#160;const uint16_t <a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a> = BC_PE_ALL;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make the current bytecode a PE hook, i.e. it will be called once the logical signature trigger matches (or always if there is none), and you have access to all the PE information. By default you only have access to execs.h information, and not to PE field information (even for PE files). </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000005">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="adab197e0485a688211ac7f6add222691"></a><!-- doxytag: member="bytecode_local.h::PE_UNPACKER_DECLARE" ref="adab197e0485a688211ac7f6add222691" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PE_UNPACKER_DECLARE&#160;&#160;&#160;const uint16_t <a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a> = BC_PE_UNPACKER;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <code>PE_HOOK_DECLARE</code>, but it is not run for packed files that pe.c can unpack (only on the unpacked file). </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000003">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a9d8dab26434a3a759f8934956f87c822"></a><!-- doxytag: member="bytecode_local.h::SIGNATURES_DECL_BEGIN" ref="a9d8dab26434a3a759f8934956f87c822" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNATURES_DECL_BEGIN&#160;&#160;&#160;struct __Signatures {</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Marks the beginning of the subsignature name declaration section. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000006">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a75c0ab3e5d9f66a1e134c823200d295d"></a><!-- doxytag: member="bytecode_local.h::SIGNATURES_DECL_END" ref="a75c0ab3e5d9f66a1e134c823200d295d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNATURES_DECL_END&#160;&#160;&#160;};</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Marks the end of the subsignature name declaration section. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000008">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af75911dca13ab8a873fe2bafd57a705a"></a><!-- doxytag: member="bytecode_local.h::SIGNATURES_DEF_BEGIN" ref="af75911dca13ab8a873fe2bafd57a705a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNATURES_DEF_BEGIN</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> __signature_bias = __COUNTER__+1;\
<span class="keyword">const</span> <span class="keyword">struct </span>__Signatures Signatures = {\
</pre></div><p>Marks the beginning of subsignature pattern definitions. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000015">config:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bytecode__local_8h.html#a9d8dab26434a3a759f8934956f87c822">SIGNATURES_DECL_BEGIN</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9b976f78a0dac8a6996cbb31571044f"></a><!-- doxytag: member="bytecode_local.h::SIGNATURES_END" ref="ac9b976f78a0dac8a6996cbb31571044f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNATURES_END&#160;&#160;&#160;};\</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Marks the end of the subsignature pattern definitions. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000017">config:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8f4214a187b6ecb97ad7eef2317ebd3f"></a><!-- doxytag: member="bytecode_local.h::TARGET" ref="a8f4214a187b6ecb97ad7eef2317ebd3f" args="(tgt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TARGET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tgt</td><td>)</td>
          <td>&#160;&#160;&#160;const unsigned short __Target = (tgt);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines the ClamAV file target. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000009">config:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>ClamAV signature type (0 - raw, 1 - PE, etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af46256c8838bde91b834ae7323f325c9"></a><!-- doxytag: member="bytecode_local.h::VIRUSNAME_PREFIX" ref="af46256c8838bde91b834ae7323f325c9" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VIRUSNAME_PREFIX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;const char __clambc_virusname_prefix[] = name;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declares the virusname prefix. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000001">config:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the prefix common to all viruses reported by this bytecode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07e03751d8c0faf422b28d7138f69a57"></a><!-- doxytag: member="bytecode_local.h::VIRUSNAMES" ref="a07e03751d8c0faf422b28d7138f69a57" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VIRUSNAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;const char *const __clambc_virusnames[] = {__VA_ARGS__};</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declares all the virusnames that this bytecode can report. </p>
<dl class="config"><dt><b><a class="el" href="config.html#_config000002">config:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>a comma-separated list of strings interpreted as virusnames </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af3a7e5cbd0c798faf98a03ee7c72e661"></a><!-- doxytag: member="bytecode_local.h::__is_bigendian" ref="af3a7e5cbd0c798faf98a03ee7c72e661" args="(void) __attribute__((const )) __attribute__((nothrow))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool __is_bigendian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the bytecode is executing on a big-endian CPU. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if executing on bigendian CPU, false otherwise </dd></dl>
<dl class="envdet"><dt><b><a class="el" href="envdet.html#_envdet000006">Environment:</a></b></dt><dd></dd></dl>
<p>This will be optimized away in libclamav, but it must be used when dealing with endianess for portability reasons. For example whenever you read a 32-bit integer from a file, it can be written in little-endian convention (x86 CPU for example), or big-endian convention (PowerPC CPU for example). If the file always contains little-endian integers, then conversion might be needed. ClamAV bytecodes by their nature must only handle known-endian integers, if endianness can change, then both situations must be taken into account (based on a 1-byte field for example). </p>

</div>
</div>
<a class="anchor" id="a50ecabc9fb33d2194b257d68fc136eed"></a><!-- doxytag: member="bytecode_local.h::cli_readint16" ref="a50ecabc9fb33d2194b257d68fc136eed" args="(const void *buff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t force_inline cli_readint16 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads from the specified buffer a 16-bit of little-endian integer. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000032">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>pointer to buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>16-bit little-endian integer converted to host endianness </dd></dl>

</div>
</div>
<a class="anchor" id="a3d6a38ce39dd509a2526a67f8f00f845"></a><!-- doxytag: member="bytecode_local.h::cli_readint32" ref="a3d6a38ce39dd509a2526a67f8f00f845" args="(const void *buff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t force_inline cli_readint32 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads from the specified buffer a 32-bit of little-endian integer. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000031">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>pointer to buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>32-bit little-endian integer converted to host endianness </dd></dl>

</div>
</div>
<a class="anchor" id="ae275f25ed41739954c981ed4717ebd22"></a><!-- doxytag: member="bytecode_local.h::cli_writeint32" ref="ae275f25ed41739954c981ed4717ebd22" args="(void *offset, uint32_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void force_inline cli_writeint32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the specified value into the specified buffer in little-endian order </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000033">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">offset</td><td>pointer to buffer to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bee86d89c2e0d16b706f62ec0c2d716"></a><!-- doxytag: member="bytecode_local.h::count_match" ref="a3bee86d89c2e0d16b706f62ec0c2d716" args="(__Signature sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t count_match </td>
          <td>(</td>
          <td class="paramtype">__Signature&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns how many times the specified signature matched. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>name of subsignature queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of times this subsignature matched in the entire file </dd></dl>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000005">Engine query:</a></b></dt><dd></dd></dl>
<p>This is a constant-time operation, the counts for all subsignatures are already computed. </p>

</div>
</div>
<a class="anchor" id="a37106786ad5566aa9fd1c8c1a0293029"></a><!-- doxytag: member="bytecode_local.h::debug" ref="a37106786ad5566aa9fd1c8c1a0293029" args="(...) __attribute__((overloadable" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debug </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>debug is an overloaded function (yes clang supports that in C!), but it only works on strings, and integers. Give an error on any other type </p>

</div>
</div>
<a class="anchor" id="aa6f11e14ec5677b64c7f623a08a81ceb"></a><!-- doxytag: member="bytecode_local.h::debug" ref="aa6f11e14ec5677b64c7f623a08a81ceb" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline void overloadable_func debug </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints <code>str</code> to clamscan's --debug output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>null terminated string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7393b44e1359ec29419ccee63a730716"></a><!-- doxytag: member="bytecode_local.h::debug" ref="a7393b44e1359ec29419ccee63a730716" args="(const uint8_t *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline void overloadable_func debug </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints <code>str</code> to clamscan's --debug output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>null terminated string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86350ab4540ed8cc1607409355a1b04c"></a><!-- doxytag: member="bytecode_local.h::debug" ref="a86350ab4540ed8cc1607409355a1b04c" args="(uint32_t a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline void overloadable_func debug </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints <code>a</code> integer to clamscan's --debug output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a801c0806f1cb7ed433f139e5769f99"></a><!-- doxytag: member="bytecode_local.h::DisassembleAt" ref="a1a801c0806f1cb7ed433f139e5769f99" args="(struct DIS_fixed *result, uint32_t offset, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t DisassembleAt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_d_i_s__fixed.html">DIS_fixed</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disassembles one X86 instruction starting at the specified offset. </p>
<dl class="disasm"><dt><b><a class="el" href="disasm.html#_disasm000005">Disassemble:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>disassembly result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>start disassembling from this offset, in the current file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>max amount of bytes to disassemble </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>offset where disassembly ended </dd></dl>

</div>
</div>
<a class="anchor" id="a95f6c4104903cf54fead01646fd7f9d2"></a><!-- doxytag: member="bytecode_local.h::foundVirus" ref="a95f6c4104903cf54fead01646fd7f9d2" args="(const char *virusname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline overloadable_func void foundVirus </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>virusname</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the specified virusname as the virus detected by this bytecode. </p>
<dl class="scanc"><dt><b><a class="el" href="scanc.html#_scanc000006">Scan:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">virusname</td><td>the name of the virus, excluding the prefix, must be one of the virusnames declared in <code>VIRUSNAMES</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bytecode__local_8h.html#a07e03751d8c0faf422b28d7138f69a57">VIRUSNAMES</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad81d7009247e53d5074a464b3a59454c"></a><!-- doxytag: member="bytecode_local.h::foundVirus" ref="ad81d7009247e53d5074a464b3a59454c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline void overloadable_func foundVirus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <a class="el" href="bytecode__local_8h.html#a95f6c4104903cf54fead01646fd7f9d2">foundVirus()</a> but just use the prefix as virusname </p>

</div>
</div>
<a class="anchor" id="ad26217bb0fe3c43d933bf48b9957bc53"></a><!-- doxytag: member="bytecode_local.h::getEntryPoint" ref="ad26217bb0fe3c43d933bf48b9957bc53" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getEntryPoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the offset of the EntryPoint in the executable file. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000047">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>offset of EP as 32-bit unsigned integer </dd></dl>

</div>
</div>
<a class="anchor" id="ae06107422b3a2bd8a9a07fb344e8a8da"></a><!-- doxytag: member="bytecode_local.h::getExeOffset" ref="ae06107422b3a2bd8a9a07fb344e8a8da" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getExeOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the offset of the executable in the file. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000048">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>offset of embedded executable inside file. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dfb3482a7f04ae1e51942755253d720"></a><!-- doxytag: member="bytecode_local.h::getFilesize" ref="a4dfb3482a7f04ae1e51942755253d720" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getFilesize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the currently scanned file's size. </p>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000010">File operation:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>file size as 32-bit unsigned integer </dd></dl>

</div>
</div>
<a class="anchor" id="a20fbd92de54ff30ade353ca8381ec766"></a><!-- doxytag: member="bytecode_local.h::getImageBase" ref="a20fbd92de54ff30ade353ca8381ec766" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getImageBase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the ImageBase with the correct endian conversion. Only works if the bytecode is a PE hook (i.e. you invoked PE_UNPACKER_DECLARE) </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000049">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ImageBase of PE file, 0 - for non-PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="acc59dfc3eb084259883225674083e553"></a><!-- doxytag: member="bytecode_local.h::getNumberOfSections" ref="acc59dfc3eb084259883225674083e553" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getNumberOfSections </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of sections in this executable file. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000044">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of sections as 16-bit unsigned integer </dd></dl>

</div>
</div>
<a class="anchor" id="a4856f8c8b2250e9ff7a15bfc651e9dc5"></a><!-- doxytag: member="bytecode_local.h::getPEBaseOfCode" ref="a4856f8c8b2250e9ff7a15bfc651e9dc5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPEBaseOfCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE BaseOfCode. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000013">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE BaseOfCode, or 0 if not in PE hook. </dd></dl>

</div>
</div>
<a class="anchor" id="a906067648342e627e35608446ae28faf"></a><!-- doxytag: member="bytecode_local.h::getPEBaseOfData" ref="a906067648342e627e35608446ae28faf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPEBaseOfData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE BaseOfData. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000014">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE BaseOfData, or 0 if not in PE hook. </dd></dl>

</div>
</div>
<a class="anchor" id="ab93887618aa8cebb250f28574634093a"></a><!-- doxytag: member="bytecode_local.h::getPECharacteristics" ref="ab93887618aa8cebb250f28574634093a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPECharacteristics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns PE characteristics. For example you can use this to check whether it is a DLL (0x2000). </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000040">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>characteristic of PE file, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a07f9eaa84e03e09a833facf15d170bff"></a><!-- doxytag: member="bytecode_local.h::getPECheckSum" ref="a07f9eaa84e03e09a833facf15d170bff" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPECheckSum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE CheckSum. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000027">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE CheckSum, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="ab9e2deafba57fe896c13e38e5d45be9e"></a><!-- doxytag: member="bytecode_local.h::getPEDataDirRVA" ref="ab9e2deafba57fe896c13e38e5d45be9e" args="(unsigned n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPEDataDirRVA </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the virtual address of specified image data directory. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000042">PE:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>image directory requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Virtual Address of requested image directory </dd></dl>

</div>
</div>
<a class="anchor" id="a19dd537d51a4bfe23f58a92b2332ed02"></a><!-- doxytag: member="bytecode_local.h::getPEDataDirSize" ref="a19dd537d51a4bfe23f58a92b2332ed02" args="(unsigned n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPEDataDirSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the size of the specified image data directory. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000043">PE:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>image directory requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size of requested image directory </dd></dl>

</div>
</div>
<a class="anchor" id="a307bc20f197de9d15bb6e08e9d8f3785"></a><!-- doxytag: member="bytecode_local.h::getPEDllCharacteristics" ref="a307bc20f197de9d15bb6e08e9d8f3785" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEDllCharacteristics </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the PE DllCharacteristics. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000029">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE DllCharacteristics, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a3d3676596ffad052f01ed7355062921c"></a><!-- doxytag: member="bytecode_local.h::getPEFileAlignment" ref="a3d3676596ffad052f01ed7355062921c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPEFileAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE FileAlignment. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000017">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE FileAlignment, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a5be87a6ddd3f434c8755a54b441da600"></a><!-- doxytag: member="bytecode_local.h::getPEImageBase" ref="a5be87a6ddd3f434c8755a54b441da600" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint64_t getPEImageBase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE ImageBase as 64-bit integer. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000015">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE ImageBase as 64-bit int, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a027ee938f8372e45d6fe6197d10ecc96"></a><!-- doxytag: member="bytecode_local.h::getPEisDLL" ref="a027ee938f8372e45d6fe6197d10ecc96" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline bool getPEisDLL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether this is a DLL. Use this only in a PE hook! </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000041">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true - the file is a DLL false - file is not a DLL </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed633b358ee0280504b9e2b55492a8d"></a><!-- doxytag: member="bytecode_local.h::getPELFANew" ref="a0ed633b358ee0280504b9e2b55492a8d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t getPELFANew </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the offset to the PE header. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000045">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>offset to the PE header, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="adae84c4057d5721d9606218d3eed5e34"></a><!-- doxytag: member="bytecode_local.h::getPELoaderFlags" ref="adae84c4057d5721d9606218d3eed5e34" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPELoaderFlags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE LoaderFlags. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000034">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE LoaderFlags or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a01fe1e273462c9386b45f7661d15b55a"></a><!-- doxytag: member="bytecode_local.h::getPEMachine" ref="a01fe1e273462c9386b45f7661d15b55a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEMachine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the CPU this executable runs on, see libclamav/pe.c for possible values. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000035">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE Machine or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="aea163191c14a5af87883231d7358070f"></a><!-- doxytag: member="bytecode_local.h::getPEMajorImageVersion" ref="aea163191c14a5af87883231d7358070f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEMajorImageVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE MajorImageVersion. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000020">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MajorImageVersion, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a0563ea1400d07e675a20ab0dcfd905eb"></a><!-- doxytag: member="bytecode_local.h::getPEMajorLinkerVersion" ref="a0563ea1400d07e675a20ab0dcfd905eb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static static force_inline force_inline uint8_t getPEMajorLinkerVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns MajorLinkerVersion for this PE file. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000008">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MajorLinkerVersion or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a220d77f9285699cf6bfda4b629193aea"></a><!-- doxytag: member="bytecode_local.h::getPEMajorOperatingSystemVersion" ref="a220d77f9285699cf6bfda4b629193aea" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEMajorOperatingSystemVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE MajorOperatingSystemVersion. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000018">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MajorOperatingSystemVersion, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a9c6364f035901ed9983edc13a709f8f4"></a><!-- doxytag: member="bytecode_local.h::getPEMajorSubsystemVersion" ref="a9c6364f035901ed9983edc13a709f8f4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEMajorSubsystemVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE MajorSubsystemVersion. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000022">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MajorSubsystemVersion or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a3c2af71ce767165317d0da8f8a23dc24"></a><!-- doxytag: member="bytecode_local.h::getPEMinorImageVersion" ref="a3c2af71ce767165317d0da8f8a23dc24" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEMinorImageVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE MinorImageVersion. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000021">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MinorrImageVersion, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="ac77d151a09c2de3b1d803567d24892b3"></a><!-- doxytag: member="bytecode_local.h::getPEMinorLinkerVersion" ref="ac77d151a09c2de3b1d803567d24892b3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint8_t getPEMinorLinkerVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns MinorLinkerVersion for this PE file. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000009">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MinorLinkerVersion or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a5b621a2c5114f83e6e1b2a2648b17909"></a><!-- doxytag: member="bytecode_local.h::getPEMinorOperatingSystemVersion" ref="a5b621a2c5114f83e6e1b2a2648b17909" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEMinorOperatingSystemVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE MinorOperatingSystemVersion. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000019">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MinorOperatingSystemVersion, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="ab8516cf0fd00093557a6b84e766f21cf"></a><!-- doxytag: member="bytecode_local.h::getPEMinorSubsystemVersion" ref="ab8516cf0fd00093557a6b84e766f21cf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPEMinorSubsystemVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE MinorSubsystemVersion. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000023">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE MinorSubsystemVersion, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a49632081cf680004297e0b2ce99c6cb8"></a><!-- doxytag: member="bytecode_local.h::getPENumberOfSymbols" ref="a49632081cf680004297e0b2ce99c6cb8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPENumberOfSymbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the PE number of debug symbols </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000038">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE NumberOfSymbols or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a3edd1734cfe7362eb26f6d6630fefb00"></a><!-- doxytag: member="bytecode_local.h::getPEPointerToSymbolTable" ref="a3edd1734cfe7362eb26f6d6630fefb00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPEPointerToSymbolTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns pointer to the PE debug symbol table </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000037">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE PointerToSymbolTable or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a564b495dcdeaccf29a0ad97046be73c1"></a><!-- doxytag: member="bytecode_local.h::getPESectionAlignment" ref="a564b495dcdeaccf29a0ad97046be73c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESectionAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SectionAlignment. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000016">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SectionAlignment, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f53af41bcca14d46ce507e2e6ab16c"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfCode" ref="ad9f53af41bcca14d46ce507e2e6ab16c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeOfCode. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000010">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfCode or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a80cc732b7672ea102d4704946c6eb2aa"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfHeaders" ref="a80cc732b7672ea102d4704946c6eb2aa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfHeaders </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeOfHeaders. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000026">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfHeaders, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="ae9c031fc42de436f574943f089c508c5"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfHeapCommit" ref="ae9c031fc42de436f574943f089c508c5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfHeapCommit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeOfHeapCommit. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000033">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfHeapCommit, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="aea6b290ae054a0b872887071b4b0f9f2"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfHeapReserve" ref="aea6b290ae054a0b872887071b4b0f9f2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfHeapReserve </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeOfHeapReserve. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000032">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfHeapReserve, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a2a8e7a0acac5e007bfb4e28d57f3170f"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfImage" ref="a2a8e7a0acac5e007bfb4e28d57f3170f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfImage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeOfImage. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000025">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfImage, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a50cf975bcf2f8fff010b8a8a26bb8ada"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfInitializedData" ref="a50cf975bcf2f8fff010b8a8a26bb8ada" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfInitializedData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeofInitializedData. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000011">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfInitializeData or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a22825914a55dbe5d5548a5e07bb0b24d"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfOptionalHeader" ref="a22825914a55dbe5d5548a5e07bb0b24d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPESizeOfOptionalHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of PE optional header. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000039">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of PE optional header, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="ae99c81416872de61956e064fc1e32550"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfStackCommit" ref="ae99c81416872de61956e064fc1e32550" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfStackCommit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeOfStackCommit. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000031">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfStackCommit, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a61370982c310e3aeed974dd0abe02284"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfStackReserve" ref="a61370982c310e3aeed974dd0abe02284" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfStackReserve </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeOfStackReserve. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000030">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeOfStackReserver, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a8bcd1876daa53ee94772ada292b039d8"></a><!-- doxytag: member="bytecode_local.h::getPESizeOfUninitializedData" ref="a8bcd1876daa53ee94772ada292b039d8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPESizeOfUninitializedData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE SizeofUninitializedData. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000012">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE SizeofUninitializedData or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a4027528d4bc10b3b736bf733db903dd1"></a><!-- doxytag: member="bytecode_local.h::getPESubsystem" ref="a4027528d4bc10b3b736bf733db903dd1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint16_t getPESubsystem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE Subsystem. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000028">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE subsystem, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a28e4809837328528a644c53d8a864fc6"></a><!-- doxytag: member="bytecode_local.h::getPETimeDateStamp" ref="a28e4809837328528a644c53d8a864fc6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPETimeDateStamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the PE TimeDateStamp from headers </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000036">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE TimeDateStamp or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a20c5188f3da8c956592847265abc287b"></a><!-- doxytag: member="bytecode_local.h::getPEWin32VersionValue" ref="a20c5188f3da8c956592847265abc287b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t getPEWin32VersionValue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the PE Win32VersionValue. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000024">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PE Win32VersionValue, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="aedc2fa35d4664099b528c68653f593f2"></a><!-- doxytag: member="bytecode_local.h::getSectionRVA" ref="aedc2fa35d4664099b528c68653f593f2" args="(unsigned i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t getSectionRVA </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the RVA of the specified section </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000051">PE:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>section index (from 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RVA of section, or -1 if invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ad81443723d60b2eaf56aa13718a0bf47"></a><!-- doxytag: member="bytecode_local.h::getSectionVirtualSize" ref="ad81443723d60b2eaf56aa13718a0bf47" args="(unsigned i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t getSectionVirtualSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the virtual size of the specified section. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000052">PE:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>section index (from 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VSZ of section, or -1 if invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a488ebd9cda9e8ba46ba5daae94ddb453"></a><!-- doxytag: member="bytecode_local.h::getVirtualEntryPoint" ref="a488ebd9cda9e8ba46ba5daae94ddb453" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t getVirtualEntryPoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The address of the EntryPoint. Use this for matching EP against sections. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000050">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>virtual address of EntryPoint, or 0 if not in PE hook </dd></dl>

</div>
</div>
<a class="anchor" id="a6241ff42b1300527c64034931f027738"></a><!-- doxytag: member="bytecode_local.h::hasExeInfo" ref="a6241ff42b1300527c64034931f027738" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline bool hasExeInfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the current file has executable information. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000005">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the file has exe info, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abfb2cd189ec07a4e521a906581e421e6"></a><!-- doxytag: member="bytecode_local.h::hasPEInfo" ref="abfb2cd189ec07a4e521a906581e421e6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline bool hasPEInfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether PE information is available </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000006">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if PE information is available (in PE hooks) </dd></dl>

</div>
</div>
<a class="anchor" id="a3c9b722b5ff4d35cfcd8de8a5c48a0ed"></a><!-- doxytag: member="bytecode_local.h::ilog2_compat" ref="a3c9b722b5ff4d35cfcd8de8a5c48a0ed" args="(uint32_t a, uint32_t b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t ilog2_compat </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ilog2_compat for 0.96 compatibility, you should use <a class="el" href="bytecode__api_8h.html#a59893a4520a13171c94d6ce63fce6c4b">ilog2()</a> 0.96.1 API instead of this one! </p>

</div>
</div>
<a class="anchor" id="a7480d681206faafd4c0f1923938dd5fe"></a><!-- doxytag: member="bytecode_local.h::isPE64" ref="a7480d681206faafd4c0f1923938dd5fe" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline bool isPE64 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether this is a PE32+ executable. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000007">PE:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this is a PE32+ executable </dd></dl>

</div>
</div>
<a class="anchor" id="a9e0a2862823999029c872ee352df036d"></a><!-- doxytag: member="bytecode_local.h::le16_to_host" ref="a9e0a2862823999029c872ee352df036d" args="(uint16_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t force_inline le16_to_host </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts the specified value if needed, knowing it is in little endian order. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000030">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>16-bit integer as read from a file </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>integer converted to host's endianess </dd></dl>

</div>
</div>
<a class="anchor" id="a9d6c63ead621ba606fe4d01b4558a9dc"></a><!-- doxytag: member="bytecode_local.h::le32_to_host" ref="a9d6c63ead621ba606fe4d01b4558a9dc" args="(uint32_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t force_inline le32_to_host </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts the specified value if needed, knowing it is in little endian order. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000028">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>32-bit integer as read from a file </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>integer converted to host's endianess </dd></dl>

</div>
</div>
<a class="anchor" id="a574fdd0c27b3c4d8289f346edb2ffc2e"></a><!-- doxytag: member="bytecode_local.h::le64_to_host" ref="a574fdd0c27b3c4d8289f346edb2ffc2e" args="(uint64_t v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t force_inline le64_to_host </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts the specified value if needed, knowing it is in little endian order. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000029">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>64-bit integer as read from a file </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>integer converted to host's endianess </dd></dl>

</div>
</div>
<a class="anchor" id="a0731ae7f531521a4c8609d75a21d3edd"></a><!-- doxytag: member="bytecode_local.h::match_location" ref="a0731ae7f531521a4c8609d75a21d3edd" args="(__Signature sig, uint32_t goback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t match_location </td>
          <td>(</td>
          <td class="paramtype">__Signature&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>goback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the offset of the match. </p>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000007">Engine query:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>- Signature </td></tr>
    <tr><td class="paramname">goback</td><td>- max length of signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>offset of match </dd></dl>

</div>
</div>
<a class="anchor" id="ae815c917305f5ce574b0e759f605819b"></a><!-- doxytag: member="bytecode_local.h::match_location_check" ref="ae815c917305f5ce574b0e759f605819b" args="(__Signature sig, uint32_t goback, const char *static_start, uint32_t static_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline int32_t match_location_check </td>
          <td>(</td>
          <td class="paramtype">__Signature&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>goback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>static_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>static_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <a class="el" href="bytecode__local_8h.html#a0731ae7f531521a4c8609d75a21d3edd">match_location()</a>, but also checks that the match starts with the specified hex string. </p>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000008">Engine query:</a></b></dt><dd>It is recommended to use this for safety and compatibility with 0.96.1 </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>- signature </td></tr>
    <tr><td class="paramname">goback</td><td>- maximum length of signature (till start of last subsig) </td></tr>
    <tr><td class="paramname">static_start</td><td>- static string that sig must begin with </td></tr>
    <tr><td class="paramname">static_len</td><td>- static string that sig must begin with - length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;=0 - offset of match -1 - no match </dd></dl>

</div>
</div>
<a class="anchor" id="afb7a07b6a6a5826f43f624fa1af2a8c6"></a><!-- doxytag: member="bytecode_local.h::matches" ref="afb7a07b6a6a5826f43f624fa1af2a8c6" args="(__Signature sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline uint32_t matches </td>
          <td>(</td>
          <td class="paramtype">__Signature&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the specified subsignature has matched at least once. </p>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000006">Engine query:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>name of subsignature queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if subsignature one or more times, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2a215ee7d930373a5df739a91ffdc10f"></a><!-- doxytag: member="bytecode_local.h::memchr" ref="a2a215ee7d930373a5df739a91ffdc10f" args="(const void *s, int c, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* memchr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scan the first <code>n</code> bytes of the buffer <code>s</code>, for the character <code>c</code>. </p>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000009">String operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>buffer to scan </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">c</td><td>character to look for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>size of buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the first byte to match, or NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a275fa6d98ae5fb2c574d7b4cfdf0ec6c"></a><!-- doxytag: member="bytecode_local.h::memcmp" ref="a275fa6d98ae5fb2c574d7b4cfdf0ec6c" args="(const void *s1, const void *s2, uint32_t n) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__(1" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* void int memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two memory buffers. </p>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000013">String operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>buffer one </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>buffer two </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>amount of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an integer less than, equal to, or greater than zero if the first <code>n</code> bytes of <code>s1</code> are found, respectively, to be less than, to match, or be greater than the first <code>n</code> bytes of <code>s2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac230c6c8d1f7ec41aed26b482001523c"></a><!-- doxytag: member="bytecode_local.h::memcpy" ref="ac230c6c8d1f7ec41aed26b482001523c" args="(void *restrict dst, const void *restrict src, uintptr_t n) __attribute__((__nothrow__)) __attribute__((__nonnull__(1" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* void memcpy </td>
          <td>(</td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies data between two non-overlapping buffers. </p>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000012">String operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>amount of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dst </dd></dl>

</div>
</div>
<a class="anchor" id="a39f394f696d30ad1fe11cf7855d33427"></a><!-- doxytag: member="bytecode_local.h::memmove" ref="a39f394f696d30ad1fe11cf7855d33427" args="(void *dst, const void *src, uintptr_t n) __attribute__((__nothrow__)) __attribute__((__nonnull__(1" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies data between two possibly overlapping buffers. </p>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000011">String operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>amount of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dst </dd></dl>

</div>
</div>
<a class="anchor" id="a9877bb88a253a26e4dbbeeff654475a7"></a><!-- doxytag: member="bytecode_local.h::memset" ref="a9877bb88a253a26e4dbbeeff654475a7" args="(void *src, int c, uintptr_t n) __attribute__((nothrow)) __attribute__((__nonnull__((1))))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills the specified buffer to the specified value. </p>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000010">String operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">src</td><td>pointer to buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to fill buffer with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>length of buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>src</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a783b0c34b69dfcdcc3c00e0172e53938"></a><!-- doxytag: member="bytecode_local.h::readPESectionName" ref="a783b0c34b69dfcdcc3c00e0172e53938" args="(unsigned char name[8], unsigned n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline int readPESectionName </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>name</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read name of requested PE section. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000046">PE:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>name of PE section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>PE section requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, &lt;0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a59c863dbbe659efa59f38a45dfc0094c"></a><!-- doxytag: member="bytecode_local.h::readRVA" ref="a59c863dbbe659efa59f38a45dfc0094c" args="(uint32_t rva, void *buf, size_t bufsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static force_inline bool readRVA </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rva</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>read the specified amount of bytes from the PE file, starting at the address specified by RVA. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000053">PE:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">rva</td><td>the Relative Virtual Address you want to read from (will be converted to file offset) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>destination buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bufsize</td><td>size of buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success (full read), false on any failure </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="bytecode__local_8h.html">bytecode_local.h</a>      </li>
      <li class="footer">Generated on Tue Oct 11 2011 12:02:34 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
