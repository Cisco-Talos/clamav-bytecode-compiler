<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>bytecode_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('bytecode__api_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bytecode_api.h File Reference</div>  </div>
</div>
<div class="contents">

<p><a href="bytecode__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a108e33201873c25ef45b59b519f1ff91">BytecodeKind</a> { <a class="el" href="bytecode__api_8h.html#a108e33201873c25ef45b59b519f1ff91aff84fbd05d167a1cf9e146d155ac90b7">BC_GENERIC</a> = 0
, <a class="el" href="bytecode__api_8h.html#a108e33201873c25ef45b59b519f1ff91aa6c849ba6dbd80a2af04a38eeea8d5c3">BC_LOGICAL</a> = 256, 
<a class="el" href="bytecode__api_8h.html#a108e33201873c25ef45b59b519f1ff91ae6b6910f9706526e49807a022b7125f1">BC_PE_UNPACKER</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="bytecode__api_8h.html#a06fc87d81c62e9abb8790b6e5713c55bacb5d73f23c5c13bca1ae5fdfbaa22d43">PE_INVALID_RVA</a> =  0xFFFFFFFF
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ac2cd51dc61c1ddf642d596c7f73a6999">FunctionalityLevels</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a8146b4e22199a811df993111bc8afc45">pdf_phase</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a5597245ed8666431babaa5371fe7e009">pdf_flag</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#abf356e8393462916811603aaf950bf0a">pdf_objflags</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="bytecode__api_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a7f53e3798ec48e79c0897ba5138f9b05">SEEK_SET</a> = 0, 
<a class="el" href="bytecode__api_8h.html#adf764cbdea00d65edcd07bb9953ad2b7af3091144c125782cf17bcd3eb84e454c">SEEK_CUR</a>, 
<a class="el" href="bytecode__api_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a060e45245be703e272d7264bafcfdc63">SEEK_END</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#af445932f85a581e254806f034225ecf1">test1</a> (uint32_t a, uint32_t b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#afa4f1c799291804204aea54ce23077d6">read</a> (uint8_t *data, int32_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads specified amount of bytes from the current file into a buffer. Also moves current position in the file.  <a href="#afa4f1c799291804204aea54ce23077d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a01d98e416d08e0eabd02d2e8aa56f28e">write</a> (uint8_t *data, int32_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the specified amount of bytes from a buffer to the current temporary file.  <a href="#a01d98e416d08e0eabd02d2e8aa56f28e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aac5ea598a656985291c56321ad2140ea">seek</a> (int32_t pos, uint32_t whence)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current file position to the specified one.  <a href="#aac5ea598a656985291c56321ad2140ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a77cd19560715e7a2f658fc3ac519d18e">setvirusname</a> (const uint8_t *name, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aa6d82179ea15d32450fefbc6d1bd8934">debug_print_str</a> (const uint8_t *str, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a6e0cdd4d4c76ed46a8627bee56eee1c1">debug_print_uint</a> (uint32_t a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a95e7d1048a56c98dec19335a6aa7afca">disasm_x86</a> (struct <a class="el" href="struct_d_i_s_a_s_m___r_e_s_u_l_t.html">DISASM_RESULT</a> *result, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a0d081f8f58263eb99d68690f1f9b2a81">pe_rawaddr</a> (uint32_t rva)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a56355a07d9fb739dd483dd756f7fe821">file_find</a> (const uint8_t *data, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a1e192cd4fe94e68dbac5023a1e2481c9">file_byteat</a> (uint32_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a8704c31c2d7a73953f3c1c320447c24a">malloc</a> (uint32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#abf709b9bcdfd2da159ec288df9dc7ad9">test2</a> (uint32_t a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ae7e5e9cef42c34a52cfe814910a1e293">get_pe_section</a> (struct <a class="el" href="structcli__exe__section.html">cli_exe_section</a> *section, uint32_t num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a5c25c11f12899883af10f3ba75cfc5c5">fill_buffer</a> (uint8_t *buffer, uint32_t len, uint32_t filled, uint32_t cursor, uint32_t fill)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aed98502eb13f9e2209d9c6b1620eb17a">extract_new</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a50b84b15fbaf03aa39b41ef7ffb5243e">read_number</a> (uint32_t radix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ab791b1626efae568e0fb62c36ce8aa74">hashset_new</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#adb42ee13e5883410846a392513d6866b">hashset_add</a> (int32_t hs, uint32_t key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a06c14cce8ec4cc839a02094547964a00">hashset_remove</a> (int32_t hs, uint32_t key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a0907920e08ec8e80f3ff829e8aaf58de">hashset_contains</a> (int32_t hs, uint32_t key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#abd5e701c80bf5346a72fb145834b865a">hashset_done</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a854fcc65ad8cc0578c55aea6bc88b193">hashset_empty</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ae755b425ff65feddef7b86092dcdeed7">buffer_pipe_new</a> (uint32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#adccae1152247859c54706b7d1753b689">buffer_pipe_new_fromfile</a> (uint32_t pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a53de1d976b1536c5b6a0d5d31de201b2">buffer_pipe_read_avail</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ac4df62495f080f7885911d71c6a379c7">buffer_pipe_read_get</a> (int32_t id, uint32_t amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ae67b360d1ab3c9dc4ac9d0f90208f6fe">buffer_pipe_read_stopped</a> (int32_t id, uint32_t amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a1b9d87fbb40620d92b57549e24b189e6">buffer_pipe_write_avail</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a8268aaabee12eed25ab561f678128ddd">buffer_pipe_write_get</a> (int32_t id, uint32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a57b76f82f0fb9bdabaad6c3d98037e94">buffer_pipe_write_stopped</a> (int32_t id, uint32_t amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a984890c1d3b68b99e68c2e6b1a7704d0">buffer_pipe_done</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a65eec3722a1e992e9e4104c037503fdc">inflate_init</a> (int32_t from_buffer, int32_t to_buffer, int32_t windowBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a10ad344e58c26566defe1780b303f0a4">inflate_process</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a123c12ca76a5b736217b68fdb126066e">inflate_done</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ad7ea886d4274f1f389acf0d5cdc50b7d">bytecode_rt_error</a> (int32_t locationid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#afb97628e1638c524b0cf45190403553d">jsnorm_init</a> (int32_t from_buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a5c0da722aa4ccb9618052c5a2361ed8e">jsnorm_process</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a7445bceea42b0a4d1d841b2c8826db4a">jsnorm_done</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a59893a4520a13171c94d6ce63fce6c4b">ilog2</a> (uint32_t a, uint32_t b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#abd69b1aa30157a6d87658db53ece8f5a">ipow</a> (int32_t a, int32_t b, int32_t c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a5d986d8e22cce16cfd2bb0cef0ac111e">iexp</a> (int32_t a, int32_t b, int32_t c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#acca08245d3d1a190375a92d5c51b2a90">isin</a> (int32_t a, int32_t b, int32_t c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a6aeece8bfb39a8499b44d67c8bebb716">icos</a> (int32_t a, int32_t b, int32_t c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a5d46e3fbbec8277f894d998a9b0dfdbc">memstr</a> (const uint8_t *haystack, int32_t haysize, const uint8_t *needle, int32_t needlesize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a231265b2ef73573c38d51a385697ae57">hex2ui</a> (uint32_t hex1, uint32_t hex2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aa07799442f1560666449446eac438ee4">atoi</a> (const uint8_t *str, int32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a43707290a22915315c960422a88ba4d4">debug_print_str_start</a> (const uint8_t *str, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a02f173e084fc9a4b9eaf3017aa4243ba">debug_print_str_nonl</a> (const uint8_t *str, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a2df1f1f4823085b4956f1bce3f5b059c">entropy_buffer</a> (uint8_t *buffer, int32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a8350ff5a10c6d2b8aa5c9b20bd0b032f">map_new</a> (int32_t keysize, int32_t valuesize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a962d8bc4658ba7dd411c75d7561c2fee">map_addkey</a> (const uint8_t *key, int32_t ksize, int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#afdae99c4fa909e017962e8b869950005">map_setvalue</a> (const uint8_t *value, int32_t vsize, int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aeadbaac505160a820fe766cdaf95aba6">map_remove</a> (const uint8_t *key, int32_t ksize, int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ac45a2c7ac861578b8001b2116eee10aa">map_find</a> (const uint8_t *key, int32_t ksize, int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aac4176bebb0d4896ad64452bec023012">map_getvaluesize</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a6a8bbb58c0ccad537eec575949e5f9f7">map_getvalue</a> (int32_t id, int32_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a2603885df2096dc840d887461c3b1aac">map_done</a> (int32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ad7479f2fd346e59217f50726be9502a3">file_find_limit</a> (const uint8_t *data, uint32_t len, int32_t maxpos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#addc54afadb3d660c92e4e350548086d8">engine_functionality_level</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a4fa59c900fefd4a4441fcc4b3e44830d">engine_dconf_level</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a0cd507ebdbadaa5899ca032cb5f69e3c">engine_scan_options</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#afc1eab4e86797378b5c1e7186894c1a7">engine_db_options</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a0f6e898d3a55355835fccb1f6d15abc1">extract_set_container</a> (uint32_t container)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a86179c9beb10be3f66cb5cae9902fec3">input_switch</a> (int32_t extracted_file)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a4e38f5731d8d7578399d6bcf97ec1a27">get_environment</a> (struct cli_environment *env, uint32_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a1b9af8b47763bc3e2d0323a605209702">disable_bytecode_if</a> (const int8_t *reason, uint32_t len, uint32_t cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#acccb9f64252a40f3857007f0e382f8eb">disable_jit_if</a> (const int8_t *reason, uint32_t len, uint32_t cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a18a8ecdd5235c80782b7e3e1892553ef">version_compare</a> (const uint8_t *lhs, uint32_t lhs_len, const uint8_t *rhs, uint32_t rhs_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a9b52373152ee8dd8fd45ea6b242e5698">check_platform</a> (uint32_t a, uint32_t b, uint32_t c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aca9074092cae6ed378ffdc5ba7cfc77e">pdf_get_obj_num</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a854b697b5e662b79c5931a7864ce0709">pdf_get_flags</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a1524216162135a13acfecc0cbc82ac03">pdf_set_flags</a> (int32_t flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a06f5560acc053270453250c387692068">pdf_lookupobj</a> (uint32_t id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a0270605365fe5bb2f721eefe6f703255">pdf_getobjsize</a> (int32_t objidx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a6504bd64de6bee96e9606260753a6ac0">pdf_getobj</a> (int32_t objidx, uint32_t amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#af7eb372ae4bc42a552e543ea2a306f5e">pdf_get_phase</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#aaa88ff051b0da6314c9655da624bb0f5">pdf_get_dumpedobjid</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a8e0bc8430adb57c0808bbf916e49185f">matchicon</a> (const uint8_t *group1, int32_t group1_len, const uint8_t *group2, int32_t group2_len)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a35a0a4f1219a792c77b7207924c3c4ec">__clambc_match_counts</a> [64]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical signature match counts.  <a href="#a35a0a4f1219a792c77b7207924c3c4ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ae39872934c5879706b3cedaef090d227">__clambc_match_offsets</a> [64]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical signature match offsets This is a low-level variable, use the Macros in <a class="el" href="bytecode__local_8h.html">bytecode_local.h</a> instead to access it.  <a href="#ae39872934c5879706b3cedaef090d227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcli__pe__hook__data.html">cli_pe_hook_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a3d386181912bdbc2b90ee559b0cccde3">__clambc_pedata</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#ab8d6c50474be3ba69906161a3e520ce7">__clambc_filesize</a> [1]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55b"></a><!-- doxytag: member="bytecode_api.h::@0" ref="a06fc87d81c62e9abb8790b6e5713c55b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55bacb5d73f23c5c13bca1ae5fdfbaa22d43"></a><!-- doxytag: member="PE_INVALID_RVA" ref="a06fc87d81c62e9abb8790b6e5713c55bacb5d73f23c5c13bca1ae5fdfbaa22d43" args="" -->PE_INVALID_RVA</em>&nbsp;</td><td>
<p>Invalid RVA specified </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7"></a><!-- doxytag: member="bytecode_api.h::@1" ref="adf764cbdea00d65edcd07bb9953ad2b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a7f53e3798ec48e79c0897ba5138f9b05"></a><!-- doxytag: member="SEEK_SET" ref="adf764cbdea00d65edcd07bb9953ad2b7a7f53e3798ec48e79c0897ba5138f9b05" args="" -->SEEK_SET</em>&nbsp;</td><td>
<p>set file position to specified absolute position </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7af3091144c125782cf17bcd3eb84e454c"></a><!-- doxytag: member="SEEK_CUR" ref="adf764cbdea00d65edcd07bb9953ad2b7af3091144c125782cf17bcd3eb84e454c" args="" -->SEEK_CUR</em>&nbsp;</td><td>
<p>set file position relative to current position </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a060e45245be703e272d7264bafcfdc63"></a><!-- doxytag: member="SEEK_END" ref="adf764cbdea00d65edcd07bb9953ad2b7a060e45245be703e272d7264bafcfdc63" args="" -->SEEK_END</em>&nbsp;</td><td>
<p>set file position relative to file end </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a108e33201873c25ef45b59b519f1ff91"></a><!-- doxytag: member="bytecode_api.h::BytecodeKind" ref="a108e33201873c25ef45b59b519f1ff91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bytecode__api_8h.html#a108e33201873c25ef45b59b519f1ff91">BytecodeKind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bytecode trigger kind </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a108e33201873c25ef45b59b519f1ff91aff84fbd05d167a1cf9e146d155ac90b7"></a><!-- doxytag: member="BC_GENERIC" ref="a108e33201873c25ef45b59b519f1ff91aff84fbd05d167a1cf9e146d155ac90b7" args="" -->BC_GENERIC</em>&nbsp;</td><td>
<p>generic bytecode, not tied a specific hook </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a108e33201873c25ef45b59b519f1ff91aa6c849ba6dbd80a2af04a38eeea8d5c3"></a><!-- doxytag: member="BC_LOGICAL" ref="a108e33201873c25ef45b59b519f1ff91aa6c849ba6dbd80a2af04a38eeea8d5c3" args="" -->BC_LOGICAL</em>&nbsp;</td><td>
<p>triggered by a logical signature </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a108e33201873c25ef45b59b519f1ff91ae6b6910f9706526e49807a022b7125f1"></a><!-- doxytag: member="BC_PE_UNPACKER" ref="a108e33201873c25ef45b59b519f1ff91ae6b6910f9706526e49807a022b7125f1" args="" -->BC_PE_UNPACKER</em>&nbsp;</td><td>
<p>a PE unpacker </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2cd51dc61c1ddf642d596c7f73a6999"></a><!-- doxytag: member="bytecode_api.h::FunctionalityLevels" ref="ac2cd51dc61c1ddf642d596c7f73a6999" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bytecode__api_8h.html#ac2cd51dc61c1ddf642d596c7f73a6999">FunctionalityLevels</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>LibClamAV functionality level constants </p>

</div>
</div>
<a class="anchor" id="a5597245ed8666431babaa5371fe7e009"></a><!-- doxytag: member="bytecode_api.h::pdf_flag" ref="a5597245ed8666431babaa5371fe7e009" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bytecode__api_8h.html#a5597245ed8666431babaa5371fe7e009">pdf_flag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PDF flags </p>

</div>
</div>
<a class="anchor" id="abf356e8393462916811603aaf950bf0a"></a><!-- doxytag: member="bytecode_api.h::pdf_objflags" ref="abf356e8393462916811603aaf950bf0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bytecode__api_8h.html#abf356e8393462916811603aaf950bf0a">pdf_objflags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PDF obj flags </p>

</div>
</div>
<a class="anchor" id="a8146b4e22199a811df993111bc8afc45"></a><!-- doxytag: member="bytecode_api.h::pdf_phase" ref="a8146b4e22199a811df993111bc8afc45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bytecode__api_8h.html#a8146b4e22199a811df993111bc8afc45">pdf_phase</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Phase of PDF parsing </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa07799442f1560666449446eac438ee4"></a><!-- doxytag: member="bytecode_api.h::atoi" ref="aa07799442f1560666449446eac438ee4" args="(const uint8_t *str, int32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t atoi </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts string to positive number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;0 string converted to number if possible, -1 on error </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000005">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a984890c1d3b68b99e68c2e6b1a7704d0"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_done" ref="a984890c1d3b68b99e68c2e6b1a7704d0" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t buffer_pipe_done </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate memory used by buffer. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000016">Data structure:</a></b></dt><dd>After this all attempts to use this buffer will result in error. All buffer_pipes are automatically deallocated when bytecode finishes execution. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of buffer_pipe </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="ae755b425ff65feddef7b86092dcdeed7"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_new" ref="ae755b425ff65feddef7b86092dcdeed7" args="(uint32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t buffer_pipe_new </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new pipe with the specified buffer size </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000008">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID of newly created buffer_pipe </dd></dl>

</div>
</div>
<a class="anchor" id="adccae1152247859c54706b7d1753b689"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_new_fromfile" ref="adccae1152247859c54706b7d1753b689" args="(uint32_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t buffer_pipe_new_fromfile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as buffer_pipe_new, except the pipe's input is tied </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000009">Data structure:</a></b></dt><dd></dd></dl>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000008">File operation:</a></b></dt><dd>to the current file, at the specified position. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>starting position of pipe input in current file </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID of newly created buffer_pipe </dd></dl>

</div>
</div>
<a class="anchor" id="a53de1d976b1536c5b6a0d5d31de201b2"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_read_avail" ref="a53de1d976b1536c5b6a0d5d31de201b2" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t buffer_pipe_read_avail </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the amount of bytes available to read. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000010">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of buffer_pipe </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount of bytes available to read </dd></dl>

</div>
</div>
<a class="anchor" id="ac4df62495f080f7885911d71c6a379c7"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_read_get" ref="ac4df62495f080f7885911d71c6a379c7" args="(int32_t id, uint32_t amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* buffer_pipe_read_get </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to the buffer for reading. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000011">Data structure:</a></b></dt><dd>The 'amount' parameter should be obtained by a call to <a class="el" href="bytecode__api_8h.html#a53de1d976b1536c5b6a0d5d31de201b2">buffer_pipe_read_avail()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of buffer_pipe </td></tr>
    <tr><td class="paramname">amount</td><td>to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to buffer, or NULL if buffer has less than specified amount </dd></dl>

</div>
</div>
<a class="anchor" id="ae67b360d1ab3c9dc4ac9d0f90208f6fe"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_read_stopped" ref="ae67b360d1ab3c9dc4ac9d0f90208f6fe" args="(int32_t id, uint32_t amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t buffer_pipe_read_stopped </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000012">Data structure:</a></b></dt><dd>Updates read cursor in buffer_pipe. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of buffer_pipe </td></tr>
    <tr><td class="paramname">amount</td><td>amount of bytes to move read cursor </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9d87fbb40620d92b57549e24b189e6"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_write_avail" ref="a1b9d87fbb40620d92b57549e24b189e6" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t buffer_pipe_write_avail </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the amount of bytes available for writing. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000013">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of buffer_pipe </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount of bytes available for writing </dd></dl>

</div>
</div>
<a class="anchor" id="a8268aaabee12eed25ab561f678128ddd"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_write_get" ref="a8268aaabee12eed25ab561f678128ddd" args="(int32_t id, uint32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* buffer_pipe_write_get </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000014">Data structure:</a></b></dt><dd>Returns pointer to writable buffer. The 'amount' parameter should be obtained by a call to <a class="el" href="bytecode__api_8h.html#a1b9d87fbb40620d92b57549e24b189e6">buffer_pipe_write_avail()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of buffer_pipe </td></tr>
    <tr><td class="paramname">size</td><td>amount of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to write buffer, or NULL if requested amount is more than what is available in the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a57b76f82f0fb9bdabaad6c3d98037e94"></a><!-- doxytag: member="bytecode_api.h::buffer_pipe_write_stopped" ref="a57b76f82f0fb9bdabaad6c3d98037e94" args="(int32_t id, uint32_t amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t buffer_pipe_write_stopped </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates the write cursor in buffer_pipe. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000015">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of buffer_pipe </td></tr>
    <tr><td class="paramname">amount</td><td>amount of bytes to move write cursor </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="ad7ea886d4274f1f389acf0d5cdc50b7d"></a><!-- doxytag: member="bytecode_api.h::bytecode_rt_error" ref="ad7ea886d4274f1f389acf0d5cdc50b7d" args="(int32_t locationid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bytecode_rt_error </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>locationid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Report a runtime error at the specified locationID. </p>
<dl class="scanc"><dt><b><a class="el" href="scanc.html#_scanc000003">Scan:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">locationid</td><td>(line &lt;&lt; 8) | (column&amp;0xff) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9b52373152ee8dd8fd45ea6b242e5698"></a><!-- doxytag: member="bytecode_api.h::check_platform" ref="a9b52373152ee8dd8fd45ea6b242e5698" args="(uint32_t a, uint32_t b, uint32_t c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t check_platform </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the JIT if the platform id matches. 0xff can be used instead of a field to mark ANY. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- os_category &lt;&lt; 24 | arch &lt;&lt; 20 | compiler &lt;&lt; 16 | flevel &lt;&lt; 8 | dconf </td></tr>
    <tr><td class="paramname">b</td><td>- big_endian &lt;&lt; 28 | sizeof_ptr &lt;&lt; 24 | cpp_version </td></tr>
    <tr><td class="paramname">c</td><td>- os_features &lt;&lt; 24 | c_version </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - no match 1 - match </dd></dl>
<dl class="envdet"><dt><b><a class="el" href="envdet.html#_envdet000005">Environment:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa6d82179ea15d32450fefbc6d1bd8934"></a><!-- doxytag: member="bytecode_api.h::debug_print_str" ref="aa6d82179ea15d32450fefbc6d1bd8934" args="(const uint8_t *str, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t debug_print_str </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints a debug message.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Message to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of message to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000001">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a02f173e084fc9a4b9eaf3017aa4243ba"></a><!-- doxytag: member="bytecode_api.h::debug_print_str_nonl" ref="a02f173e084fc9a4b9eaf3017aa4243ba" args="(const uint8_t *str, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t debug_print_str_nonl </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints a debug message with a trailing newline, and not preceded by 'LibClamAV debug'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string </td></tr>
    <tr><td class="paramname">len</td><td>length of <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000007">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a43707290a22915315c960422a88ba4d4"></a><!-- doxytag: member="bytecode_api.h::debug_print_str_start" ref="a43707290a22915315c960422a88ba4d4" args="(const uint8_t *str, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t debug_print_str_start </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints a debug message with a trailing newline, but preceded by 'LibClamAV debug'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string </td></tr>
    <tr><td class="paramname">len</td><td>length of <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000006">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6e0cdd4d4c76ed46a8627bee56eee1c1"></a><!-- doxytag: member="bytecode_api.h::debug_print_uint" ref="a6e0cdd4d4c76ed46a8627bee56eee1c1" args="(uint32_t a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t debug_print_uint </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints a number as a debug message. This is like <code>debug_print_str_nonl!</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>number to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000002">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1b9af8b47763bc3e2d0323a605209702"></a><!-- doxytag: member="bytecode_api.h::disable_bytecode_if" ref="a1b9af8b47763bc3e2d0323a605209702" args="(const int8_t *reason, uint32_t len, uint32_t cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t disable_bytecode_if </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the bytecode completely if condition is true. Can only be called from the BC_STARTUP bytecode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>- why the bytecode had to be disabled </td></tr>
    <tr><td class="paramname">len</td><td>- length of reason </td></tr>
    <tr><td class="paramname">cond</td><td>- condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - auto mode 1 - JIT disabled 2 - fully disabled </dd></dl>
<dl class="envdet"><dt><b><a class="el" href="envdet.html#_envdet000002">Environment:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="acccb9f64252a40f3857007f0e382f8eb"></a><!-- doxytag: member="bytecode_api.h::disable_jit_if" ref="acccb9f64252a40f3857007f0e382f8eb" args="(const int8_t *reason, uint32_t len, uint32_t cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t disable_jit_if </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the JIT completely if condition is true. Can only be called from the BC_STARTUP bytecode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>- why the JIT had to be disabled </td></tr>
    <tr><td class="paramname">len</td><td>- length of reason </td></tr>
    <tr><td class="paramname">cond</td><td>- condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - auto mode 1 - JIT disabled 2 - fully disabled </dd></dl>
<dl class="envdet"><dt><b><a class="el" href="envdet.html#_envdet000003">Environment:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a95e7d1048a56c98dec19335a6aa7afca"></a><!-- doxytag: member="bytecode_api.h::disasm_x86" ref="a95e7d1048a56c98dec19335a6aa7afca" args="(struct DISASM_RESULT *result, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t disasm_x86 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_d_i_s_a_s_m___r_e_s_u_l_t.html">DISASM_RESULT</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disassembles starting from current file position, the specified amount of bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to struct holding result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>how many bytes to disassemble </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success</dd></dl>
<p>You can use lseek to disassemble starting from a different location. This is a low-level API, the result is in ClamAV type-8 signature format (64 bytes/instruction). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bytecode__local_8h.html#a1a801c0806f1cb7ed433f139e5769f99">DisassembleAt</a> </dd></dl>
<dl class="disasm"><dt><b><a class="el" href="disasm.html#_disasm000001">Disassemble:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afc1eab4e86797378b5c1e7186894c1a7"></a><!-- doxytag: member="bytecode_api.h::engine_db_options" ref="afc1eab4e86797378b5c1e7186894c1a7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t engine_db_options </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the current engine's db options. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_DB_* flags </dd></dl>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000004">Engine query:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4fa59c900fefd4a4441fcc4b3e44830d"></a><!-- doxytag: member="bytecode_api.h::engine_dconf_level" ref="a4fa59c900fefd4a4441fcc4b3e44830d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t engine_dconf_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the current engine (dconf) functionality level. Usually identical to <a class="el" href="bytecode__api_8h.html#addc54afadb3d660c92e4e350548086d8">engine_functionality_level()</a>, unless distro backported patches. Compare with <a class="el" href="bytecode__api_8h.html#ac2cd51dc61c1ddf642d596c7f73a6999">FunctionalityLevels</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an integer representing the DCONF (security fixes) level. </dd></dl>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000002">Engine query:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="addc54afadb3d660c92e4e350548086d8"></a><!-- doxytag: member="bytecode_api.h::engine_functionality_level" ref="addc54afadb3d660c92e4e350548086d8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t engine_functionality_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the current engine (feature) functionality level. To map these to ClamAV releases, compare it with <a class="el" href="bytecode__api_8h.html#ac2cd51dc61c1ddf642d596c7f73a6999">FunctionalityLevels</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an integer representing current engine functionality level. </dd></dl>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000001">Engine query:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0cd507ebdbadaa5899ca032cb5f69e3c"></a><!-- doxytag: member="bytecode_api.h::engine_scan_options" ref="a0cd507ebdbadaa5899ca032cb5f69e3c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t engine_scan_options </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the current engine's scan options. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CL_SCAN* flags </dd></dl>
<dl class="engineq"><dt><b><a class="el" href="engineq.html#_engineq000003">Engine query:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2df1f1f4823085b4956f1bce3f5b059c"></a><!-- doxytag: member="bytecode_api.h::entropy_buffer" ref="a2df1f1f4823085b4956f1bce3f5b059c" args="(uint8_t *buffer, int32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t entropy_buffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an approximation for the entropy of <code>buffer</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>input buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>entropy estimation * 2^26 </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000008">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aed98502eb13f9e2209d9c6b1620eb17a"></a><!-- doxytag: member="bytecode_api.h::extract_new" ref="aed98502eb13f9e2209d9c6b1620eb17a" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t extract_new </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepares for extracting a new file, if we've already extracted one it scans it. </p>
<dl class="scanc"><dt><b><a class="el" href="scanc.html#_scanc000002">Scan:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>an id for the new file (for example position in container) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if previous extracted file was infected </dd></dl>

</div>
</div>
<a class="anchor" id="a0f6e898d3a55355835fccb1f6d15abc1"></a><!-- doxytag: member="bytecode_api.h::extract_set_container" ref="a0f6e898d3a55355835fccb1f6d15abc1" args="(uint32_t container)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t extract_set_container </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the container type for the currently extracted file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>container type (CL_TYPE_*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>current setting for container (CL_TYPE_ANY default) </dd></dl>
<dl class="scanc"><dt><b><a class="el" href="scanc.html#_scanc000004">Scan:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1e192cd4fe94e68dbac5023a1e2481c9"></a><!-- doxytag: member="bytecode_api.h::file_byteat" ref="a1e192cd4fe94e68dbac5023a1e2481c9" args="(uint32_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t file_byteat </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a single byte from current file </p>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000005">File operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>file offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>byte at offset <code>off</code> in the current file, or -1 if offset is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a56355a07d9fb739dd483dd756f7fe821"></a><!-- doxytag: member="bytecode_api.h::file_find" ref="a56355a07d9fb739dd483dd756f7fe821" args="(const uint8_t *data, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t file_find </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks for the specified sequence of bytes in the current file. </p>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000004">File operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the sequence of bytes to look for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>length of <code>data</code>, cannot be more than 1024 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>offset in the current file if match is found, -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad7479f2fd346e59217f50726be9502a3"></a><!-- doxytag: member="bytecode_api.h::file_find_limit" ref="ad7479f2fd346e59217f50726be9502a3" args="(const uint8_t *data, uint32_t len, int32_t maxpos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t file_find_limit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>maxpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks for the specified sequence of bytes in the current file, up to the specified position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the sequence of bytes to look for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>length of <code>data</code>, cannot be more than 1024 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxpos</td><td>maximum position to look for a match, note that this is 1 byte after the end of last possible match: match_pos + <code>len</code> &lt; <code>maxpos</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>offset in the current file if match is found, -1 otherwise </dd></dl>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000009">File operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5c25c11f12899883af10f3ba75cfc5c5"></a><!-- doxytag: member="bytecode_api.h::fill_buffer" ref="a5c25c11f12899883af10f3ba75cfc5c5" args="(uint8_t *buffer, uint32_t len, uint32_t filled, uint32_t cursor, uint32_t fill)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t fill_buffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>filled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills the specified buffer with at least <code>fill</code> bytes. </p>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000006">File operation:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>the buffer to fill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filled</td><td>how much of the buffer is currently filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cursor</td><td>position of cursor in buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fill</td><td>amount of bytes to fill in (0 is valid) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 on error, 0 on EOF, number bytes available in buffer (starting from 0) The character at the cursor will be at position 0 after this call. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e38f5731d8d7578399d6bcf97ec1a27"></a><!-- doxytag: member="bytecode_api.h::get_environment" ref="a4e38f5731d8d7578399d6bcf97ec1a27" args="(struct cli_environment *env, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_environment </td>
          <td>(</td>
          <td class="paramtype">struct cli_environment *&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the environment this bytecode runs in. Used by BC_STARTUP to disable bytecode when bugs are known for the current platform. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">env</td><td>- the full environment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>- size of <code>env</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl class="envdet"><dt><b><a class="el" href="envdet.html#_envdet000001">Environment:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae7e5e9cef42c34a52cfe814910a1e293"></a><!-- doxytag: member="bytecode_api.h::get_pe_section" ref="ae7e5e9cef42c34a52cfe814910a1e293" args="(struct cli_exe_section *section, uint32_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t get_pe_section </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcli__exe__section.html">cli_exe_section</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets information about the specified PE section. </p>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000002">PE:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">section</td><td>PE section information will be stored here </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>PE section number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - success -1 - failure </dd></dl>

</div>
</div>
<a class="anchor" id="adb42ee13e5883410846a392513d6866b"></a><!-- doxytag: member="bytecode_api.h::hashset_add" ref="adb42ee13e5883410846a392513d6866b" args="(int32_t hs, uint32_t key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hashset_add </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a new 32-bit key to the hashset. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000003">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hs</td><td>ID of hashset (from hashset_new) </td></tr>
    <tr><td class="paramname">key</td><td>the key to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="a0907920e08ec8e80f3ff829e8aaf58de"></a><!-- doxytag: member="bytecode_api.h::hashset_contains" ref="a0907920e08ec8e80f3ff829e8aaf58de" args="(int32_t hs, uint32_t key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hashset_contains </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the hashset contains the specified key. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000005">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hs</td><td>ID of hashset (from hashset_new) </td></tr>
    <tr><td class="paramname">key</td><td>the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if found, 0 if not found, &lt;0 on invalid hashset ID </dd></dl>

</div>
</div>
<a class="anchor" id="abd5e701c80bf5346a72fb145834b865a"></a><!-- doxytag: member="bytecode_api.h::hashset_done" ref="abd5e701c80bf5346a72fb145834b865a" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hashset_done </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocates the memory used by the specified hashset. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000006">Data structure:</a></b></dt><dd>Trying to use the hashset after this will result in an error. The hashset may not be used after this. All hashsets are automatically deallocated when bytecode finishes execution. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of hashset (from hashset_new) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="a854fcc65ad8cc0578c55aea6bc88b193"></a><!-- doxytag: member="bytecode_api.h::hashset_empty" ref="a854fcc65ad8cc0578c55aea6bc88b193" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hashset_empty </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether the hashset is empty. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000007">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of hashset (from hashset_new) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="ab791b1626efae568e0fb62c36ce8aa74"></a><!-- doxytag: member="bytecode_api.h::hashset_new" ref="ab791b1626efae568e0fb62c36ce8aa74" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hashset_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new hashset and returns its id. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000002">Data structure:</a></b></dt><dd></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID for new hashset </dd></dl>

</div>
</div>
<a class="anchor" id="a06c14cce8ec4cc839a02094547964a00"></a><!-- doxytag: member="bytecode_api.h::hashset_remove" ref="a06c14cce8ec4cc839a02094547964a00" args="(int32_t hs, uint32_t key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hashset_remove </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a 32-bit key from the hashset. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000004">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hs</td><td>ID of hashset (from hashset_new) </td></tr>
    <tr><td class="paramname">key</td><td>the key to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="a231265b2ef73573c38d51a385697ae57"></a><!-- doxytag: member="bytecode_api.h::hex2ui" ref="a231265b2ef73573c38d51a385697ae57" args="(uint32_t hex1, uint32_t hex2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hex2ui </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns hexadecimal characters <code>hex1</code> and <code>hex2</code> converted to 8-bit number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hex1</td><td>hexadecimal character </td></tr>
    <tr><td class="paramname">hex2</td><td>hexadecimal character </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>hex1 hex2 converted to 8-bit integer, -1 on error </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000004">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6aeece8bfb39a8499b44d67c8bebb716"></a><!-- doxytag: member="bytecode_api.h::icos" ref="a6aeece8bfb39a8499b44d67c8bebb716" args="(int32_t a, int32_t b, int32_t c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t icos </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns c*cos(a/b). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer </td></tr>
    <tr><td class="paramname">b</td><td>integer </td></tr>
    <tr><td class="paramname">c</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>c*sin(a/b) </dd></dl>
<dl class="math"><dt><b><a class="el" href="math.html#_math000005">Math function:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5d986d8e22cce16cfd2bb0cef0ac111e"></a><!-- doxytag: member="bytecode_api.h::iexp" ref="a5d986d8e22cce16cfd2bb0cef0ac111e" args="(int32_t a, int32_t b, int32_t c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t iexp </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns exp(a/b)*c </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer </td></tr>
    <tr><td class="paramname">b</td><td>integer </td></tr>
    <tr><td class="paramname">c</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>c*exp(a/b) </dd></dl>
<dl class="math"><dt><b><a class="el" href="math.html#_math000003">Math function:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a59893a4520a13171c94d6ce63fce6c4b"></a><!-- doxytag: member="bytecode_api.h::ilog2" ref="a59893a4520a13171c94d6ce63fce6c4b" args="(uint32_t a, uint32_t b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ilog2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns 2^26*log2(a/b) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input </td></tr>
    <tr><td class="paramname">b</td><td>input </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>2^26*log2(a/b) </dd></dl>
<dl class="math"><dt><b><a class="el" href="math.html#_math000001">Math function:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a123c12ca76a5b736217b68fdb126066e"></a><!-- doxytag: member="bytecode_api.h::inflate_done" ref="a123c12ca76a5b736217b68fdb126066e" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t inflate_done </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocates inflate data structure. Using the inflate data structure after this will result in an error. All inflate data structures are automatically deallocated when bytecode finishes execution. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000019">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of inflate data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a65eec3722a1e992e9e4104c037503fdc"></a><!-- doxytag: member="bytecode_api.h::inflate_init" ref="a65eec3722a1e992e9e4104c037503fdc" args="(int32_t from_buffer, int32_t to_buffer, int32_t windowBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t inflate_init </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>from_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>to_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>windowBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes inflate data structures for decompressing data </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000017">Data structure:</a></b></dt><dd>'from_buffer' and writing uncompressed uncompressed data 'to_buffer'. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">from_buffer</td><td>ID of buffer_pipe to read compressed data from </td></tr>
    <tr><td class="paramname">to_buffer</td><td>ID of buffer_pipe to write decompressed data to </td></tr>
    <tr><td class="paramname">windowBits</td><td>(see zlib documentation) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID of newly created inflate data structure, &lt;0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a10ad344e58c26566defe1780b303f0a4"></a><!-- doxytag: member="bytecode_api.h::inflate_process" ref="a10ad344e58c26566defe1780b303f0a4" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t inflate_process </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inflate all available data in the input buffer, and write to output buffer. Stops when the input buffer becomes empty, or write buffer becomes full. Also attempts to recover from corrupted inflate stream (via inflateSync). This function can be called repeatedly on success after filling the input buffer, and flushing the output buffer. The inflate stream is done processing when 0 bytes are available from output buffer, and input buffer is not empty. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000018">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of inflate data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, zlib error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a86179c9beb10be3f66cb5cae9902fec3"></a><!-- doxytag: member="bytecode_api.h::input_switch" ref="a86179c9beb10be3f66cb5cae9902fec3" args="(int32_t extracted_file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t input_switch </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>extracted_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Toggles the read/seek API to read from the currently extracted file, and back. You must call seek after switching inputs to position the cursor to a valid position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">extracted_file</td><td>1 - switch to reading from extracted file, 0 - switch back to original input </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on error (if no extracted file exists) 0 on success </dd></dl>
<dl class="scanc"><dt><b><a class="el" href="scanc.html#_scanc000005">Scan:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abd69b1aa30157a6d87658db53ece8f5a"></a><!-- doxytag: member="bytecode_api.h::ipow" ref="abd69b1aa30157a6d87658db53ece8f5a" args="(int32_t a, int32_t b, int32_t c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ipow </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns c*a^b. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer </td></tr>
    <tr><td class="paramname">b</td><td>integer </td></tr>
    <tr><td class="paramname">c</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>c*pow(a,b) </dd></dl>
<dl class="math"><dt><b><a class="el" href="math.html#_math000002">Math function:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="acca08245d3d1a190375a92d5c51b2a90"></a><!-- doxytag: member="bytecode_api.h::isin" ref="acca08245d3d1a190375a92d5c51b2a90" args="(int32_t a, int32_t b, int32_t c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t isin </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns c*sin(a/b). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>integer </td></tr>
    <tr><td class="paramname">b</td><td>integer </td></tr>
    <tr><td class="paramname">c</td><td>integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>c*sin(a/b) </dd></dl>
<dl class="math"><dt><b><a class="el" href="math.html#_math000004">Math function:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7445bceea42b0a4d1d841b2c8826db4a"></a><!-- doxytag: member="bytecode_api.h::jsnorm_done" ref="a7445bceea42b0a4d1d841b2c8826db4a" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t jsnorm_done </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flushes JS normalizer. </p>
<dl class="js"><dt><b><a class="el" href="js.html#_js000003">JavaScript:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of js normalizer to flush </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - success -1 - failure </dd></dl>

</div>
</div>
<a class="anchor" id="afb97628e1638c524b0cf45190403553d"></a><!-- doxytag: member="bytecode_api.h::jsnorm_init" ref="afb97628e1638c524b0cf45190403553d" args="(int32_t from_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t jsnorm_init </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>from_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes JS normalizer for reading 'from_buffer'. Normalized JS will be written to a single tempfile, one normalized JS per line, and automatically scanned when the bytecode finishes execution. </p>
<dl class="js"><dt><b><a class="el" href="js.html#_js000001">JavaScript:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">from_buffer</td><td>ID of buffer_pipe to read javascript from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID of JS normalizer, &lt;0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a5c0da722aa4ccb9618052c5a2361ed8e"></a><!-- doxytag: member="bytecode_api.h::jsnorm_process" ref="a5c0da722aa4ccb9618052c5a2361ed8e" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t jsnorm_process </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalize all javascript from the input buffer, and write to tempfile. You can call this function repeatedly on success, if you (re)fill the input buffer. </p>
<dl class="js"><dt><b><a class="el" href="js.html#_js000002">JavaScript:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of JS normalizer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, &lt;0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8704c31c2d7a73953f3c1c320447c24a"></a><!-- doxytag: member="bytecode_api.h::malloc" ref="a8704c31c2d7a73953f3c1c320447c24a" args="(uint32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* malloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates memory. Currently this memory is freed automatically on exit from the bytecode, and there is no way to free it sooner. </p>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000001">Data structure:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>amount of memory to allocate in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to allocated memory </dd></dl>

</div>
</div>
<a class="anchor" id="a962d8bc4658ba7dd411c75d7561c2fee"></a><!-- doxytag: member="bytecode_api.h::map_addkey" ref="a962d8bc4658ba7dd411c75d7561c2fee" args="(const uint8_t *key, int32_t ksize, int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t map_addkey </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts the specified key/value pair into the map. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of table </td></tr>
    <tr><td class="paramname">key</td><td>key </td></tr>
    <tr><td class="paramname">ksize</td><td>size of <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - if key existed before 1 - if key didn't exist before &lt;0 - if ksize doesn't match keysize specified at table creation </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000021">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2603885df2096dc840d887461c3b1aac"></a><!-- doxytag: member="bytecode_api.h::map_done" ref="a2603885df2096dc840d887461c3b1aac" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t map_done </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocates the memory used by the specified map. Trying to use the map after this will result in an error. All maps are automatically deallocated when the bytecode finishes execution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of map </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - success -1 - invalid map </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000027">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac45a2c7ac861578b8001b2116eee10aa"></a><!-- doxytag: member="bytecode_api.h::map_find" ref="ac45a2c7ac861578b8001b2116eee10aa" args="(const uint8_t *key, int32_t ksize, int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t map_find </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up key in map. The map remember the last looked up key (so you can retrieve the value).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of map </td></tr>
    <tr><td class="paramname">key</td><td>key </td></tr>
    <tr><td class="paramname">ksize</td><td>size of key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - if not found 1 - if found &lt;0 - if ksize doesn't match the size specified at table creation </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000024">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6a8bbb58c0ccad537eec575949e5f9f7"></a><!-- doxytag: member="bytecode_api.h::map_getvalue" ref="a6a8bbb58c0ccad537eec575949e5f9f7" args="(int32_t id, int32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* map_getvalue </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the value obtained during last map_find. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of map. </td></tr>
    <tr><td class="paramname">size</td><td>size of value (obtained from map_getvaluesize) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000026">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aac4176bebb0d4896ad64452bec023012"></a><!-- doxytag: member="bytecode_api.h::map_getvaluesize" ref="aac4176bebb0d4896ad64452bec023012" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t map_getvaluesize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the size of value obtained during last map_find. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of value </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000025">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8350ff5a10c6d2b8aa5c9b20bd0b032f"></a><!-- doxytag: member="bytecode_api.h::map_new" ref="a8350ff5a10c6d2b8aa5c9b20bd0b032f" args="(int32_t keysize, int32_t valuesize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t map_new </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>valuesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new map and returns its id. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keysize</td><td>size of key </td></tr>
    <tr><td class="paramname">valuesize</td><td>size of value, if 0 then value is allocated separately </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID of new map </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000020">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aeadbaac505160a820fe766cdaf95aba6"></a><!-- doxytag: member="bytecode_api.h::map_remove" ref="aeadbaac505160a820fe766cdaf95aba6" args="(const uint8_t *key, int32_t ksize, int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t map_remove </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove an element from the map. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of map </td></tr>
    <tr><td class="paramname">key</td><td>key </td></tr>
    <tr><td class="paramname">ksize</td><td>size of key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, key was present 1 if key was not present &lt;0 if ksize doesn't match keysize specified at table creation </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000023">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afdae99c4fa909e017962e8b869950005"></a><!-- doxytag: member="bytecode_api.h::map_setvalue" ref="afdae99c4fa909e017962e8b869950005" args="(const uint8_t *value, int32_t vsize, int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t map_setvalue </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>vsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the value for the last inserted key with map_addkey. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of table </td></tr>
    <tr><td class="paramname">value</td><td>value </td></tr>
    <tr><td class="paramname">vsize</td><td>size of <code>value</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - if update was successful &lt;0 - if there is no last key </dd></dl>
<dl class="adt"><dt><b><a class="el" href="adt.html#_adt000022">Data structure:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8e0bc8430adb57c0808bbf916e49185f"></a><!-- doxytag: member="bytecode_api.h::matchicon" ref="a8e0bc8430adb57c0808bbf916e49185f" args="(const uint8_t *group1, int32_t group1_len, const uint8_t *group2, int32_t group2_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t matchicon </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>group1_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>group2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>group2_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempts to match current executable's icon against the specified icon groups. </p>
<dl class="icon"><dt><b><a class="el" href="icon.html#_icon000001">Icon:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group1</td><td>- same as GROUP1 in LDB signatures </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">group1_len</td><td>- length of <code>group1</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group2</td><td>- same as GROUP2 in LDB signatures </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">group2_len</td><td>- length of <code>group2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 - invalid call, or sizes (only valid for PE hooks) 0 - not a match 1 - match </dd></dl>

</div>
</div>
<a class="anchor" id="a5d46e3fbbec8277f894d998a9b0dfdbc"></a><!-- doxytag: member="bytecode_api.h::memstr" ref="a5d46e3fbbec8277f894d998a9b0dfdbc" args="(const uint8_t *haystack, int32_t haysize, const uint8_t *needle, int32_t needlesize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t memstr </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>haysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>needlesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return position of match, -1 otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>buffer to search </td></tr>
    <tr><td class="paramname">haysize</td><td>size of <code>haystack</code> </td></tr>
    <tr><td class="paramname">needle</td><td>substring to search </td></tr>
    <tr><td class="paramname">needlesize</td><td>size of needle </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>location of match, -1 otherwise </dd></dl>
<dl class="stringops"><dt><b><a class="el" href="stringops.html#_stringops000003">String operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aaa88ff051b0da6314c9655da624bb0f5"></a><!-- doxytag: member="bytecode_api.h::pdf_get_dumpedobjid" ref="aaa88ff051b0da6314c9655da624bb0f5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pdf_get_dumpedobjid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the currently dumped obj index. </p>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000008">PDF:</a></b></dt><dd>Valid only in PDF_PHASE_POSTDUMP. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&gt;=0 - object index -1 - invalid phase </dd></dl>

</div>
</div>
<a class="anchor" id="a854b697b5e662b79c5931a7864ce0709"></a><!-- doxytag: member="bytecode_api.h::pdf_get_flags" ref="a854b697b5e662b79c5931a7864ce0709" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pdf_get_flags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the flags for the entire PDF (as set so far). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 - if not called from PDF hook &gt;=0 - pdf flags </dd></dl>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000002">PDF:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aca9074092cae6ed378ffdc5ba7cfc77e"></a><!-- doxytag: member="bytecode_api.h::pdf_get_obj_num" ref="aca9074092cae6ed378ffdc5ba7cfc77e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pdf_get_obj_num </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return number of pdf objects </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 - if not called from PDF hook &gt;=0 - number of PDF objects </dd></dl>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000001">PDF:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af7eb372ae4bc42a552e543ea2a306f5e"></a><!-- doxytag: member="bytecode_api.h::pdf_get_phase" ref="af7eb372ae4bc42a552e543ea2a306f5e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pdf_get_phase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an 'enum pdf_phase'. </p>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000007">PDF:</a></b></dt><dd>Identifies at which phase this bytecode was called. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current <a class="el" href="bytecode__api_8h.html#a8146b4e22199a811df993111bc8afc45">pdf_phase</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6504bd64de6bee96e9606260753a6ac0"></a><!-- doxytag: member="bytecode_api.h::pdf_getobj" ref="a6504bd64de6bee96e9606260753a6ac0" args="(int32_t objidx, uint32_t amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pdf_getobj </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>objidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the undecoded object. </p>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000006">PDF:</a></b></dt><dd>Meant only for reading, write modifies the fmap buffer, so avoid! </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">objidx</td><td>- object index (from 0), not object id! </td></tr>
    <tr><td class="paramname">amount</td><td>- size returned by pdf_getobjsize (or smaller) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL - invalid objidx/amount pointer - pointer to original object </dd></dl>

</div>
</div>
<a class="anchor" id="a0270605365fe5bb2f721eefe6f703255"></a><!-- doxytag: member="bytecode_api.h::pdf_getobjsize" ref="a0270605365fe5bb2f721eefe6f703255" args="(int32_t objidx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pdf_getobjsize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>objidx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size of the specified PDF obj. </p>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000005">PDF:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">objidx</td><td>- object index (from 0), not object id! </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - if not called from PDF hook, or invalid objnum &gt;=0 - size of object </dd></dl>

</div>
</div>
<a class="anchor" id="a06f5560acc053270453250c387692068"></a><!-- doxytag: member="bytecode_api.h::pdf_lookupobj" ref="a06f5560acc053270453250c387692068" args="(uint32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pdf_lookupobj </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lookup pdf object with specified id. </p>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000004">PDF:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>- pdf id (objnumber &lt;&lt; 8 | generationid) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 - if object id doesn't exist &gt;=0 - object index </dd></dl>

</div>
</div>
<a class="anchor" id="a1524216162135a13acfecc0cbc82ac03"></a><!-- doxytag: member="bytecode_api.h::pdf_set_flags" ref="a1524216162135a13acfecc0cbc82ac03" args="(int32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pdf_set_flags </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the flags for the entire PDF. It is recommended that you retrieve old flags, and just add new ones. </p>
<dl class="pdfg"><dt><b><a class="el" href="pdfg.html#_pdfg000003">PDF:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>- flags to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 - success -1 - invalid phase </dd></dl>

</div>
</div>
<a class="anchor" id="a0d081f8f58263eb99d68690f1f9b2a81"></a><!-- doxytag: member="bytecode_api.h::pe_rawaddr" ref="a0d081f8f58263eb99d68690f1f9b2a81" args="(uint32_t rva)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pe_rawaddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rva</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a RVA (Relative Virtual Address) to an absolute PE file offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rva</td><td>a rva address from the PE file </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>absolute file offset mapped to the <code>rva</code>, or PE_INVALID_RVA if the <code>rva</code> is invalid. </dd></dl>
<dl class="pe"><dt><b><a class="el" href="pe.html#_pe000001">PE:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afa4f1c799291804204aea54ce23077d6"></a><!-- doxytag: member="bytecode_api.h::read" ref="afa4f1c799291804204aea54ce23077d6" args="(uint8_t *data, int32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads specified amount of bytes from the current file into a buffer. Also moves current position in the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of bytes to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to buffer where data is read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount read. </dd></dl>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000001">File operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a50b84b15fbaf03aa39b41ef7ffb5243e"></a><!-- doxytag: member="bytecode_api.h::read_number" ref="a50b84b15fbaf03aa39b41ef7ffb5243e" args="(uint32_t radix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t read_number </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>radix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads a number in the specified radix starting from the current position. </p>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000007">File operation:</a></b></dt><dd>Non-numeric characters are ignored. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radix</td><td>10 or 16 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number read </dd></dl>

</div>
</div>
<a class="anchor" id="aac5ea598a656985291c56321ad2140ea"></a><!-- doxytag: member="bytecode_api.h::seek" ref="aac5ea598a656985291c56321ad2140ea" args="(int32_t pos, uint32_t whence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t seek </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>whence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the current file position to the specified one. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bytecode__api_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a7f53e3798ec48e79c0897ba5138f9b05">SEEK_SET</a>, <a class="el" href="bytecode__api_8h.html#adf764cbdea00d65edcd07bb9953ad2b7af3091144c125782cf17bcd3eb84e454c">SEEK_CUR</a>, <a class="el" href="bytecode__api_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a060e45245be703e272d7264bafcfdc63">SEEK_END</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>offset (absolute or relative depending on <code>whence</code> param) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whence</td><td>one of <code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>absolute position in file </dd></dl>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000003">File operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a77cd19560715e7a2f658fc3ac519d18e"></a><!-- doxytag: member="bytecode_api.h::setvirusname" ref="a77cd19560715e7a2f658fc3ac519d18e" args="(const uint8_t *name, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t setvirusname </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the name of the virus found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the virus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the virusname </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl class="scanc"><dt><b><a class="el" href="scanc.html#_scanc000001">Scan:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af445932f85a581e254806f034225ecf1"></a><!-- doxytag: member="bytecode_api.h::test1" ref="af445932f85a581e254806f034225ecf1" args="(uint32_t a, uint32_t b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t test1 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test api. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>0xf00dbeef </td></tr>
    <tr><td class="paramname">b</td><td>0xbeeff00d </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0x12345678 if parameters match, 0x55 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abf709b9bcdfd2da159ec288df9dc7ad9"></a><!-- doxytag: member="bytecode_api.h::test2" ref="abf709b9bcdfd2da159ec288df9dc7ad9" args="(uint32_t a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t test2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test api2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>0xf00d </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0xd00f if parameter matches, 0x5555 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a18a8ecdd5235c80782b7e3e1892553ef"></a><!-- doxytag: member="bytecode_api.h::version_compare" ref="a18a8ecdd5235c80782b7e3e1892553ef" args="(const uint8_t *lhs, uint32_t lhs_len, const uint8_t *rhs, uint32_t rhs_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t version_compare </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lhs_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rhs_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two version numbers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>- left hand side of comparison </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lhs_len</td><td>- length of <code>lhs</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>- right hand side of comparison </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs_len</td><td>- length of <code>rhs</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 - lhs &lt; rhs 0 - lhs == rhs 1 - lhs &gt; rhs </dd></dl>
<dl class="envdet"><dt><b><a class="el" href="envdet.html#_envdet000004">Environment:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a01d98e416d08e0eabd02d2e8aa56f28e"></a><!-- doxytag: member="bytecode_api.h::write" ref="a01d98e416d08e0eabd02d2e8aa56f28e" args="(uint8_t *data, int32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the specified amount of bytes from a buffer to the current temporary file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to buffer of data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>amount of bytes to write <code>size</code> bytes to temporary file, from the buffer pointed to byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>amount of bytes successfully written </dd></dl>
<dl class="fileops"><dt><b><a class="el" href="fileops.html#_fileops000002">File operation:</a></b></dt><dd></dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ab8d6c50474be3ba69906161a3e520ce7"></a><!-- doxytag: member="bytecode_api.h::__clambc_filesize" ref="ab8d6c50474be3ba69906161a3e520ce7" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="bytecode__api_8h.html#ab8d6c50474be3ba69906161a3e520ce7">__clambc_filesize</a>[1]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>File size (max 4G). </p>
<dl class="globals"><dt><b><a class="el" href="globals.html#_globals000004">Global variable:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6eb3802e21949cfdf6b91570d3c62c99"></a><!-- doxytag: member="bytecode_api.h::__clambc_kind" ref="a6eb3802e21949cfdf6b91570d3c62c99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t <a class="el" href="bytecode__api_8h.html#a6eb3802e21949cfdf6b91570d3c62c99">__clambc_kind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Kind of the bytecode </p>
<dl class="globals"><dt><b><a class="el" href="globals.html#_globals000005">Global variable:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a35a0a4f1219a792c77b7207924c3c4ec"></a><!-- doxytag: member="bytecode_api.h::__clambc_match_counts" ref="a35a0a4f1219a792c77b7207924c3c4ec" args="[64]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="bytecode__api_8h.html#a35a0a4f1219a792c77b7207924c3c4ec">__clambc_match_counts</a>[64]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Logical signature match counts. </p>
<p>This is a low-level variable, use the Macros in <a class="el" href="bytecode__local_8h.html">bytecode_local.h</a> instead to access it. </p>
<dl class="globals"><dt><b><a class="el" href="globals.html#_globals000001">Global variable:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae39872934c5879706b3cedaef090d227"></a><!-- doxytag: member="bytecode_api.h::__clambc_match_offsets" ref="ae39872934c5879706b3cedaef090d227" args="[64]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="bytecode__api_8h.html#ae39872934c5879706b3cedaef090d227">__clambc_match_offsets</a>[64]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Logical signature match offsets This is a low-level variable, use the Macros in <a class="el" href="bytecode__local_8h.html">bytecode_local.h</a> instead to access it. </p>
<dl class="globals"><dt><b><a class="el" href="globals.html#_globals000002">Global variable:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a3d386181912bdbc2b90ee559b0cccde3"></a><!-- doxytag: member="bytecode_api.h::__clambc_pedata" ref="a3d386181912bdbc2b90ee559b0cccde3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcli__pe__hook__data.html">cli_pe_hook_data</a> <a class="el" href="bytecode__api_8h.html#a3d386181912bdbc2b90ee559b0cccde3">__clambc_pedata</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PE data, if this is a PE hook. </p>
<dl class="globals"><dt><b><a class="el" href="globals.html#_globals000003">Global variable:</a></b></dt><dd></dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="bytecode__api_8h.html">bytecode_api.h</a>      </li>
      <li class="footer">Generated on Tue Oct 11 2011 12:02:34 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
